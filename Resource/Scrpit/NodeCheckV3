/**
 * NodeCheck V3 - ä»£ç†èŠ‚ç‚¹æ£€æµ‹ä¸ç®¡ç†è„šæœ¬
 * 
 * æ ¸å¿ƒåŠŸèƒ½ï¼š
 * - æ”¯æŒå…¥å£æ£€æµ‹å’Œè½åœ°æ£€æµ‹
 * - è‡ªåŠ¨èŠ‚ç‚¹å‘½åå’Œå»é‡
 * - æŒä¹…åŒ–ç¼“å­˜æœºåˆ¶
 * - æ”¯æŒå¤šç§ä»£ç†å®¢æˆ·ç«¯
 * - èŠ‚ç‚¹æ€§èƒ½æµ‹è¯•
 * - æ™ºèƒ½åˆ†ç±»å’Œç­›é€‰
 * 
 * æ”¯æŒçš„å®¢æˆ·ç«¯ï¼š
 * - Surge (å¸¦/ä¸å¸¦ ability å‚æ•°)
 * - Loon
 * - Clash
 * - Shadowrocket
 * 
 * å‚æ•°è¯´æ˜ï¼š
 * - [flag]        å¢åŠ è½åœ°å›½å®¶/åœ°åŒºæ——å¸œæ ‡è¯† (é»˜è®¤: false)
 * - [inflag]      å¢åŠ å…¥å£å›½å®¶/åœ°åŒºæ——å¸œæ ‡è¯† (é»˜è®¤: false)
 * - [xy]          å…³é—­è½åœ°æ£€æµ‹ï¼Œä»…æŸ¥è¯¢å…¥å£ (é»˜è®¤: false)
 * - [iisp]        æ˜¾ç¤ºå…¥å£è¿è¥å•†ä¿¡æ¯ (é»˜è®¤: false)
 * - [yisp]        æ˜¾ç¤ºè½åœ°è¿è¥å•†ä¿¡æ¯ (é»˜è®¤: false)
 * - [city]        æ˜¾ç¤ºå…¥å£åŸå¸‚ (é»˜è®¤: false)
 * - [sheng]       æ˜¾ç¤ºå…¥å£çœä»½ (é»˜è®¤: false)
 * - [yuan]        ä¸ºå¢ƒå¤–å…¥å£æ·»åŠ çœŸå®å±åœ°æ ‡è¯† (é»˜è®¤: false)
 * - [yw]          è½åœ°å½’å±åœ°ä½¿ç”¨è‹±æ–‡ç¼©å†™ (é»˜è®¤: false)
 * - [game]        å¢åŠ æ¸¸æˆèŠ‚ç‚¹æ ‡è¯† (é»˜è®¤: false)
 * - [bl]          ä¿ç•™å€ç‡æ ‡è¯† (é»˜è®¤: false)
 * - [snone]       æ¸…ç†å•èŠ‚ç‚¹åœ°åŒºçš„åºå· (é»˜è®¤: false)
 * - [offtz]       å…³é—­é€šçŸ¥ (é»˜è®¤: false)
 * - [dns]         å°†èŠ‚ç‚¹åŸŸåè§£æä¸ºIP (é»˜è®¤: false)
 * - [debug]       è°ƒè¯•æ—¥å¿— (é»˜è®¤: false)
 * - [fgf]         è®¾ç½®å…¥å£å’Œè½åœ°åˆ†éš”ç¬¦ (é»˜è®¤: " ")
 * - [sn]          è®¾ç½®å›½å®¶ä¸åºå·åˆ†éš”ç¬¦ (é»˜è®¤: " ")
 * - [name]        ä¸ºèŠ‚ç‚¹æ·»åŠ æœºåœºåç§°å‰ç¼€
 * - [timeout]     APIè¶…æ—¶æ—¶é—´ (é»˜è®¤: 2000ms)
 * - [cd]          æœ‰ç¼“å­˜æ—¶çš„APIè¶…æ—¶æ—¶é—´ (é»˜è®¤: 0ms)
 * - [bs]          æ‰¹å¤„ç†èŠ‚ç‚¹æ•° (é»˜è®¤: 10)
 * - [h]           ç¼“å­˜æœ‰æ•ˆæœŸ(å°æ—¶) (é»˜è®¤: 48)
 * - [min]         ç¼“å­˜æœ‰æ•ˆæœŸ(åˆ†é’Ÿ)
 * 
 * ç¤ºä¾‹ä½¿ç”¨ï¼š
 * - åŸºç¡€é…ç½®ï¼šhttps://raw.githubusercontent.com/your-repo/NodeCheckV3.js
 * - å¸¦å‚æ•°ï¼šhttps://raw.githubusercontent.com/your-repo/NodeCheckV3.js#flag&iisp&city
 */

const SUB_STORE_SCHEMA = {
  title: "NodeCheck V3",
  description: "ä»£ç†èŠ‚ç‚¹æ£€æµ‹ä¸ç®¡ç†è„šæœ¬ï¼Œæ”¯æŒå¤šå®¢æˆ·ç«¯ï¼Œè‡ªåŠ¨å‘½åå»é‡",
  scope: ["Surge", "Loon", "Clash", "Shadowrocket"],
  author: "Your Name",
  updateTime: "2026-01-24 00:00:00",
  version: "3.0.0",
  params: {
    flag: {
      datatype: "boolean",
      description: "å¢åŠ è½åœ°å›½å®¶/åœ°åŒºæ——å¸œæ ‡è¯†",
      defaultValue: false,
    },
    inflag: {
      datatype: "boolean",
      description: "å¢åŠ å…¥å£å›½å®¶/åœ°åŒºæ——å¸œæ ‡è¯†",
      defaultValue: false,
    },
    xy: {
      datatype: "boolean",
      description: "å…³é—­è½åœ°æ£€æµ‹ï¼Œä»…æŸ¥è¯¢å…¥å£",
      defaultValue: false,
    },
    iisp: {
      datatype: "boolean",
      description: "æ˜¾ç¤ºå…¥å£è¿è¥å•†ä¿¡æ¯",
      defaultValue: false,
    },
    yisp: {
      datatype: "boolean",
      description: "æ˜¾ç¤ºè½åœ°è¿è¥å•†ä¿¡æ¯",
      defaultValue: false,
    },
    city: {
      datatype: "boolean",
      description: "æ˜¾ç¤ºå…¥å£åŸå¸‚",
      defaultValue: false,
    },
    sheng: {
      datatype: "boolean",
      description: "æ˜¾ç¤ºå…¥å£çœä»½",
      defaultValue: false,
    },
    yuan: {
      datatype: "boolean",
      description: "ä¸ºå¢ƒå¤–å…¥å£æ·»åŠ çœŸå®å±åœ°æ ‡è¯†",
      defaultValue: false,
    },
    yw: {
      datatype: "boolean",
      description: "è½åœ°å½’å±åœ°ä½¿ç”¨è‹±æ–‡ç¼©å†™",
      defaultValue: false,
    },
    game: {
      datatype: "boolean",
      description: "å¢åŠ æ¸¸æˆèŠ‚ç‚¹æ ‡è¯†",
      defaultValue: false,
    },
    bl: {
      datatype: "boolean",
      description: "ä¿ç•™å€ç‡æ ‡è¯†",
      defaultValue: false,
    },
    snone: {
      datatype: "boolean",
      description: "æ¸…ç†å•èŠ‚ç‚¹åœ°åŒºçš„åºå·",
      defaultValue: false,
    },
    offtz: {
      datatype: "boolean",
      description: "å…³é—­é€šçŸ¥",
      defaultValue: false,
    },
    dns: {
      datatype: "boolean",
      description: "å°†èŠ‚ç‚¹åŸŸåè§£æä¸ºIP",
      defaultValue: false,
    },
    debug: {
      datatype: "boolean",
      description: "è°ƒè¯•æ—¥å¿—",
      defaultValue: false,
    },
    fgf: {
      datatype: "string",
      description: "è®¾ç½®å…¥å£å’Œè½åœ°åˆ†éš”ç¬¦",
      defaultValue: " ",
    },
    sn: {
      datatype: "string",
      description: "è®¾ç½®å›½å®¶ä¸åºå·åˆ†éš”ç¬¦",
      defaultValue: " ",
    },
    name: {
      datatype: "string",
      description: "ä¸ºèŠ‚ç‚¹æ·»åŠ æœºåœºåç§°å‰ç¼€",
      defaultValue: "",
    },
    timeout: {
      datatype: "number",
      description: "APIè¶…æ—¶æ—¶é—´(æ¯«ç§’)",
      defaultValue: 2000,
    },
    cd: {
      datatype: "number",
      description: "æœ‰ç¼“å­˜æ—¶çš„APIè¶…æ—¶æ—¶é—´(æ¯«ç§’)",
      defaultValue: 0,
    },
    bs: {
      datatype: "number",
      description: "æ‰¹å¤„ç†èŠ‚ç‚¹æ•°",
      defaultValue: 10,
    },
    h: {
      datatype: "number",
      description: "ç¼“å­˜æœ‰æ•ˆæœŸ(å°æ—¶)",
      defaultValue: 48,
    },
    min: {
      datatype: "number",
      description: "ç¼“å­˜æœ‰æ•ˆæœŸ(åˆ†é’Ÿ)",
      defaultValue: "",
    },
  },
};

// å…¨å±€å˜é‡
const $ = $substore;
const iar = $arguments;
const debug = iar.debug || false;

// å‚æ•°è§£æ
const params = {
  flag: iar.flag || false,
  inflag: iar.inflag || false,
  xy: iar.xy || false,
  iisp: iar.iisp || false,
  yisp: iar.yisp || false,
  city: iar.city || false,
  sheng: iar.sheng || false,
  yuan: iar.yuan || false,
  yw: iar.yw || false,
  game: iar.game || false,
  bl: iar.bl || false,
  snone: iar.snone || false,
  offtz: iar.offtz || false,
  dns: iar.dns || false,
  fgf: iar.fgf ? decodeURI(iar.fgf) : " ",
  sn: iar.sn ? decodeURI(iar.sn) : " ",
  name: iar.name ? decodeURI(iar.name) : "",
  timeout: iar.timeout ? parseInt(iar.timeout) : 2000,
  cd: iar.cd ? parseInt(iar.cd) : 0,
  bs: iar.bs ? parseInt(iar.bs) : 10,
  h: iar.h ? parseInt(iar.h) : 48,
  min: iar.min ? parseInt(iar.min) : "",
};

// ç¯å¢ƒæ£€æµ‹
const env = $substore.env || {};
const { isLoon = false, isSurge = false, isClash = false, isShadowrocket = false } = env;
const targetPlatform = isLoon ? "Loon" : isSurge ? "Surge" : isClash ? "Clash" : isShadowrocket ? "Shadowrocket" : "Unknown";

// ç¼“å­˜é…ç½®
const CACHE_KEY_PREFIX = "nodecheck-v3-";
const DEFAULT_CACHE_TTL = 48 * 3600 * 1000; // 48å°æ—¶
let cacheTTL = params.min ? params.min * 60 * 1000 : params.h * 3600 * 1000;

// å·¥å…·å‡½æ•°
function log(...args) {
  if (debug) {
    console.log(`[NodeCheck V3] ${args.join(" ")}`);
  }
}

function notify(title, subtitle, message) {
  if (!params.offtz) {
    $.notify(title, subtitle, message);
  }
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function getFlag(countryCode) {
  const code = countryCode.toUpperCase();
  const flag = code.split("").map(c => 127397 + c.charCodeAt());
  return String.fromCodePoint(...flag).replace(/ğŸ‡¹ğŸ‡¼/g, "ğŸ‡¨ğŸ‡³");
}

function getCacheKey(type, id) {
  return `${CACHE_KEY_PREFIX}${type}-${id}`;
}

// APIè°ƒç”¨å°è£…
async function fetchAPI(url, options = {}) {
  const { timeout = params.timeout, proxy = null, retry = 2 } = options;
  
  for (let i = 0; i <= retry; i++) {
    try {
      const response = await Promise.race([
        $.http.get({ url, proxy }),
        new Promise((_, reject) => setTimeout(() => reject(new Error("timeout")), timeout))
      ]);
      return JSON.parse(response.body);
    } catch (error) {
      log(`APIè¯·æ±‚å¤±è´¥ (${i+1}/${retry+1}): ${url}, é”™è¯¯: ${error.message}`);
      if (i === retry) {
        throw error;
      }
      await sleep(500 * (i + 1)); // æŒ‡æ•°é€€é¿
    }
  }
}

// å…¥å£æ£€æµ‹ - è·å–IPä¿¡æ¯
async function getIPInfo(ip) {
  const cacheKey = getCacheKey("ip", ip);
  const cached = scriptResourceCache.get(cacheKey);
  
  if (cached) {
    log(`ä½¿ç”¨ç¼“å­˜çš„IPä¿¡æ¯: ${ip}`);
    return cached;
  }
  
  try {
    // ä¼˜å…ˆä½¿ç”¨å›½å†…APIï¼Œå¤±è´¥åä½¿ç”¨ip-api
    let data;
    try {
      data = await fetchAPI(`https://api.v3.speedtest.cn/api/location/geo?ip=${ip}`);
      if (data && !data.message) {
        const result = {
          country: data.country || "",
          countryCode: data.country_code || "",
          regionName: data.province || "",
          city: data.city || "",
          isp: data.isp || "",
          query: ip,
        };
        scriptResourceCache.set(cacheKey, result);
        return result;
      }
    } catch (error) {
      log(`å›½å†…APIå¤±è´¥ï¼Œä½¿ç”¨ip-api: ${error.message}`);
    }
    
    // ä½¿ç”¨ip-apiä½œä¸ºå¤‡ç”¨
    data = await fetchAPI(`http://ip-api.com/json/${ip}?lang=zh-CN&fields=status,message,country,countryCode,regionName,city,isp,query`);
    if (data.status === "success") {
      scriptResourceCache.set(cacheKey, data);
      return data;
    }
    
    throw new Error(data.message || "IPä¿¡æ¯è·å–å¤±è´¥");
  } catch (error) {
    log(`è·å–IPä¿¡æ¯å¤±è´¥: ${ip}, é”™è¯¯: ${error.message}`);
    throw error;
  }
}

// è½åœ°æ£€æµ‹ - è·å–ä»£ç†å‡ºå£ä¿¡æ¯
async function getProxyInfo(proxy) {
  const cacheKey = getCacheKey("proxy", JSON.stringify(proxy));
  const cached = scriptResourceCache.get(cacheKey);
  
  if (cached) {
    log(`ä½¿ç”¨ç¼“å­˜çš„ä»£ç†ä¿¡æ¯: ${proxy.name}`);
    return cached;
  }
  
  try {
    const proxyConfig = ProxyUtils.produce([proxy], targetPlatform);
    const data = await fetchAPI(`http://ip-api.com/json?lang=zh-CN&fields=status,message,country,countryCode,city,query,isp`, {
      proxy: proxyConfig,
      timeout: params.timeout
    });
    
    if (data.status === "success") {
      scriptResourceCache.set(cacheKey, data);
      return data;
    }
    
    throw new Error(data.message || "ä»£ç†ä¿¡æ¯è·å–å¤±è´¥");
  } catch (error) {
    log(`è·å–ä»£ç†ä¿¡æ¯å¤±è´¥: ${proxy.name}, é”™è¯¯: ${error.message}`);
    throw error;
  }
}

// DNSè§£æ
async function resolveDNS(domain) {
  const cacheKey = getCacheKey("dns", domain);
  const cached = scriptResourceCache.get(cacheKey);
  
  if (cached) {
    log(`ä½¿ç”¨ç¼“å­˜çš„DNSè§£æ: ${domain}`);
    return cached;
  }
  
  try {
    // ä½¿ç”¨å…¬å…±DNSæœåŠ¡è¿›è¡Œè§£æ
    const data = await fetchAPI(`https://1.1.1.1/dns-query?name=${domain}&type=A`, {
      headers: { "accept": "application/dns-json" }
    });
    
    if (data.Answer && data.Answer.length > 0) {
      const ip = data.Answer[0].data;
      scriptResourceCache.set(cacheKey, ip);
      return ip;
    }
    
    return domain; // è§£æå¤±è´¥åˆ™è¿”å›åŸåŸŸå
  } catch (error) {
    log(`DNSè§£æå¤±è´¥: ${domain}, é”™è¯¯: ${error.message}`);
    return domain;
  }
}

// èŠ‚ç‚¹å¤„ç†ä¸»å‡½æ•°
async function operator(proxies = [], targetPlatform, env) {
  const startTime = Date.now();
  const totalNodes = proxies.length;
  
  log(`å¼€å§‹å¤„ç† ${totalNodes} ä¸ªèŠ‚ç‚¹ï¼Œç›®æ ‡å¹³å°: ${targetPlatform}`);
  notify(`NodeCheck V3 å¼€å§‹å¤„ç†`, `å…± ${totalNodes} ä¸ªèŠ‚ç‚¹`, ``);
  
  // æ£€æŸ¥ç¼“å­˜æ”¯æŒ
  if (typeof scriptResourceCache === "undefined") {
    log("ç¼“å­˜åŠŸèƒ½ä¸å¯ç”¨ï¼Œä½¿ç”¨å†…å­˜ç¼“å­˜");
  }
  
  // æ‰¹é‡å¤„ç†èŠ‚ç‚¹
  const batchSize = params.bs;
  const processedNodes = [];
  
  for (let i = 0; i < proxies.length; i += batchSize) {
    const batch = proxies.slice(i, i + batchSize);
    log(`å¤„ç†æ‰¹æ¬¡ ${Math.floor(i / batchSize) + 1}/${Math.ceil(proxies.length / batchSize)}: ${batch.length} ä¸ªèŠ‚ç‚¹`);
    
    const batchResults = await Promise.allSettled(
      batch.map(async (proxy) => {
        try {
          return await processNode(proxy);
        } catch (error) {
          log(`å¤„ç†èŠ‚ç‚¹å¤±è´¥: ${proxy.name}, é”™è¯¯: ${error.message}`);
          return null;
        }
      })
    );
    
    // æ”¶é›†æˆåŠŸå¤„ç†çš„èŠ‚ç‚¹
    batchResults.forEach(result => {
      if (result.status === "fulfilled" && result.value) {
        processedNodes.push(result.value);
      }
    });
    
    // è¿›åº¦é€šçŸ¥
    const progress = Math.min((i + batchSize) / proxies.length * 100, 100);
    if (!params.offtz && progress % 20 === 0) {
      notify(`NodeCheck V3 å¤„ç†ä¸­`, `è¿›åº¦: ${Math.round(progress)}%`, `å·²å¤„ç† ${processedNodes.length}/${totalNodes} ä¸ªèŠ‚ç‚¹`);
    }
    
    // é¿å…è¯·æ±‚è¿‡äºé¢‘ç¹
    await sleep(100);
  }
  
  // èŠ‚ç‚¹å»é‡
  const uniqueNodes = deduplicateNodes(processedNodes);
  
  // èŠ‚ç‚¹å‘½åå’Œç¼–å·
  const namedNodes = nameNodes(uniqueNodes);
  
  // æ¸…ç†å•ä¸ªèŠ‚ç‚¹çš„åºå·
  const finalNodes = params.snone ? cleanSingleNodeNumbers(namedNodes) : namedNodes;
  
  // æ·»åŠ æœºåœºåç§°å‰ç¼€
  if (params.name) {
    finalNodes.forEach(node => {
      node.name = `${params.name} ${node.name}`;
    });
  }
  
  const endTime = Date.now();
  const duration = endTime - startTime;
  
  log(`å¤„ç†å®Œæˆï¼Œå…± ${finalNodes.length} ä¸ªèŠ‚ç‚¹ï¼Œè€—æ—¶ ${duration}ms`);
  
  // å®Œæˆé€šçŸ¥
  if (!params.offtz) {
    notify(
      `NodeCheck V3 å¤„ç†å®Œæˆ`,
      `å…± ${totalNodes} ä¸ªèŠ‚ç‚¹ï¼ŒæˆåŠŸ ${finalNodes.length} ä¸ª`,
      `è€—æ—¶: ${Math.round(duration / 1000)}ç§’`
    );
  }
  
  return finalNodes;
}

// å¤„ç†å•ä¸ªèŠ‚ç‚¹
async function processNode(proxy) {
  try {
    let server = proxy.server;
    
    // DNSè§£æ
    if (params.dns && !/^\d+\.\d+\.\d+\.\d+$/.test(server)) {
      server = await resolveDNS(server);
      log(`DNSè§£æ: ${proxy.server} -> ${server}`);
    }
    
    // å…¥å£æ£€æµ‹
    const entranceInfo = await getIPInfo(server);
    
    // è½åœ°æ£€æµ‹ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    let landingInfo = entranceInfo;
    if (!params.xy) {
      try {
        landingInfo = await getProxyInfo(proxy);
      } catch (error) {
        log(`è½åœ°æ£€æµ‹å¤±è´¥ï¼Œä½¿ç”¨å…¥å£ä¿¡æ¯: ${proxy.name}`);
        // è½åœ°æ£€æµ‹å¤±è´¥æ—¶ä½¿ç”¨å…¥å£ä¿¡æ¯
      }
    }
    
    // ç”ŸæˆèŠ‚ç‚¹ä¿¡æ¯
    const nodeInfo = {
      ...proxy,
      server: params.dns ? server : proxy.server,
      _entrance: entranceInfo,
      _landing: landingInfo,
      _qc: `${entranceInfo.query}${landingInfo.query}`, // å»é‡æ ‡è¯†
    };
    
    return nodeInfo;
  } catch (error) {
    log(`å¤„ç†èŠ‚ç‚¹å¤±è´¥: ${proxy.name}, é”™è¯¯: ${error.message}`);
    return null;
  }
}

// èŠ‚ç‚¹å»é‡
function deduplicateNodes(nodes) {
  const uniqueMap = new Map();
  
  for (const node of nodes) {
    if (node && node._qc) {
      if (!uniqueMap.has(node._qc)) {
        uniqueMap.set(node._qc, node);
      }
    }
  }
  
  const result = Array.from(uniqueMap.values());
  log(`èŠ‚ç‚¹å»é‡: ${nodes.length} -> ${result.length} ä¸ª`);
  return result;
}

// èŠ‚ç‚¹å‘½å
function nameNodes(nodes) {
  // æŒ‰åœ°åŒºåˆ†ç»„
  const groups = nodes.reduce((acc, node) => {
    const { _entrance, _landing } = node;
    const entrance = params.xy ? _landing : _entrance;
    const landing = _landing;
    
    // æ„å»ºåœ°åŒºæ ‡è¯†
    let region = "";
    if (entrance.country === "ä¸­å›½") {
      if (params.sheng && params.city) {
        region = `${entrance.regionName} ${entrance.city}`;
      } else if (params.sheng) {
        region = entrance.regionName;
      } else if (params.city) {
        region = entrance.city;
      } else {
        region = entrance.country;
      }
    } else {
      region = params.yw ? landing.countryCode : landing.country;
    }
    
    // æ·»åŠ è¿è¥å•†ä¿¡æ¯
    let operator = "";
    if (params.iisp) {
      const isp = entrance.isp || "";
      const operatorMap = { ç”µä¿¡: "ğŸ…³", è”é€š: "ğŸ…»", ç§»åŠ¨: "ğŸ†ˆ", å¹¿ç”µ: "ğŸ…¶" };
      const operatorFlag = Object.keys(operatorMap).find(key => isp.includes(key));
      operator = operatorFlag ? operatorMap[operatorFlag] : "ğŸ…²";
    }
    
    // æ·»åŠ æ——å¸œæ ‡è¯†
    let flag = "";
    if (params.flag) {
      flag = getFlag(landing.countryCode);
    }
    
    // æ·»åŠ å…¥å£æ——å¸œæ ‡è¯†
    let inFlag = "";
    if (params.inflag) {
      inFlag = getFlag(entrance.countryCode);
    }
    
    // æ„å»ºåŸºç¡€åç§°
    const baseName = [inFlag, operator, region, params.flag ? flag : "", params.yw ? "" : landing.city].filter(Boolean).join(params.fgf);
    
    if (!acc[baseName]) {
      acc[baseName] = [];
    }
    acc[baseName].push(node);
    
    return acc;
  }, {});
  
  // ä¸ºæ¯ç»„èŠ‚ç‚¹ç¼–å·
  const namedNodes = [];
  for (const [baseName, group] of Object.entries(groups)) {
    group.forEach((node, index) => {
      const number = (index + 1).toString().padStart(2, "0");
      node.name = `${baseName}${params.sn}${number}`;
      namedNodes.push(node);
    });
  }
  
  return namedNodes;
}

// æ¸…ç†å•ä¸ªèŠ‚ç‚¹çš„åºå·
function cleanSingleNodeNumbers(nodes) {
  const groups = nodes.reduce((acc, node) => {
    const baseName = node.name.replace(/\s+\d+$/, "");
    if (!acc[baseName]) {
      acc[baseName] = [];
    }
    acc[baseName].push(node);
    return acc;
  }, {});
  
  for (const [baseName, group] of Object.entries(groups)) {
    if (group.length === 1 && group[0].name.endsWith("01")) {
      group[0].name = baseName;
    }
  }
  
  return nodes;
}

// ç¡®ä¿operatorå‡½æ•°è¢«å¯¼å‡º
if (typeof module !== "undefined" && module.exports) {
  module.exports = { operator, SUB_STORE_SCHEMA };
}
