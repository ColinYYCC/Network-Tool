/**
 * @Sub-Store-Page
 * CNAME æ¥å£æŸ¥è¯¢å»é‡/é‡å‘½å 2026-01-25
 * - å…¥å£æŸ¥è¯¢[å›½å†…spapi è¯†åˆ«åˆ°å›½å¤–ä¸ºip-api] è½åœ°æŸ¥è¯¢[ip-api]
 * - æ ¹æ®æ¥å£è¿”å›çš„çœŸå®ç»“æœï¼Œé‡æ–°å¯¹èŠ‚ç‚¹å‘½åã€‚
 * - æ·»åŠ å…¥å£åŸå¸‚ã€è½åœ°å›½å®¶æˆ–åœ°åŒºã€å›½å†…è¿è¥å•†ä¿¡æ¯ï¼Œå¹¶å¯¹è¿™äº›æ•°æ®åšæŒä¹…åŒ–ç¼“å­˜ï¼ˆ48å°æ—¶æœ‰æ•ˆæœŸï¼‰ï¼Œå‡å°‘APIè¯·æ±‚æ¬¡æ•°ï¼Œæé«˜è¿è¡Œæ•ˆç‡ã€‚
 * - ä»…å…¼å®¹ Surge, Loon å®¢æˆ·ç«¯ã€‚
 * - Surge éœ€è¦å›ºå®šå¸¦ ability å‚æ•°ç‰ˆæœ¬ã€‚
 * ç‰¹åˆ«è¯´æ˜ï¼š
 * - ç¬¦å·ï¼šğŸ…³ç”µä¿¡ ğŸ…»è”é€š ğŸ†ˆç§»åŠ¨ ğŸ…¶å¹¿ç”µ ğŸ…²å…¬å¸ ğŸ†‰ç›´è¿ ğŸ®æ¸¸æˆ
 * - é¦–æ¬¡è¿è¡Œæˆ–è€…åœ¨æ²¡æœ‰ç¼“å­˜çš„æƒ…å†µä¸‹ä¼šé€šçŸ¥è¿›åº¦
 * - æ— å‚æ•°æ—¶çš„èŠ‚ç‚¹å‘½åæ ¼å¼: "ç¾å›½ 01"
 * - 1. å®˜æ–¹é»˜è®¤ç‰ˆ(ç›®å‰ä¸å¸¦ ability å‚æ•°, ä¸ä¿è¯ä»¥åä¸ä¼šæ”¹åŠ¨): ã€‹https://raw.githubusercontent.com/sub-store-org/Sub-Store/master/config/Surge.sgmodule
 *
 * - 2. å›ºå®šå¸¦ ability å‚æ•°ç‰ˆæœ¬,å¯èƒ½ä¼šçˆ†å†…å­˜, å¦‚æœéœ€è¦ä½¿ç”¨æŒ‡å®šèŠ‚ç‚¹åŠŸèƒ½ ä¾‹å¦‚ [åŠ å›½æ——è„šæœ¬æˆ–è€…cnameè„šæœ¬] è¯·ä½¿ç”¨æ­¤å¸¦ ability å‚æ•°ç‰ˆæœ¬: https://raw.githubusercontent.com/sub-store-org/Sub-Store/master/config/Surge-ability.sgmodule
 *
 * - 3. å›ºå®šä¸å¸¦ ability å‚æ•°ç‰ˆæœ¬ï¼šhttps://raw.githubusercontent.com/sub-store-org/Sub-Store/master/config/Surge-Noability.sgmodule
 *
 * - å‚æ•°å¿…é¡»ä»¥"#"å¼€å¤´ï¼Œå¤šä¸ªå‚æ•°ä½¿ç”¨"&"è¿æ¥ï¼Œä¾‹å¦‚ https://github.com/Keywos/rule/raw/main/cname.js#city&iisp&name=Name
 * - ä»¥ä¸‹æ˜¯æ­¤è„šæœ¬æ”¯æŒçš„å‚æ•°ï¼Œå¿…é¡»ä»¥"#"å¼€å¤´ï¼Œå¤šä¸ªå‚æ•°ä½¿ç”¨"&"è¿æ¥ï¼Œéœ€è¦ä¼ å…¥å‚æ•°çš„è¯ç”¨ "=" ä¾‹å¦‚ "name=ä¸€å…ƒ" å‚è€ƒä¸Šè¿°åœ°å€ä¸ºä¾‹ä½¿ç”¨å‚æ•°ã€‚
 * - æ— å‚æ•°æ—¶çš„èŠ‚ç‚¹å‘½åæ ¼å¼: "ç¾å›½ 01"ï¼Œå¦‚æœ [å…¥å£IPæˆ–å›½å®¶]æˆ– [è½åœ°IPæˆ–å›½å®¶]ä¸€æ ·åˆ™ä¸º "ç›´è¿ å¾·å›½ 01" 
 * - é¦–æ¬¡è¿è¡Œæˆ–è€…åœ¨æ²¡æœ‰ç¼“å­˜çš„æƒ…å†µä¸‹ä¼šé€šçŸ¥è¿›åº¦
 * 
 * 
 * å…¥å£å‚æ•°
 * - [iisp]      å¢åŠ å…¥å£è¿è¥å•†æˆ–è€…ç›´è¿æ ‡è¯†ï¼›
 * - [city]      å¢åŠ å…¥å£åŸå¸‚æ–‡å­—æ ‡è¯†ï¼›
 * - [sheng]     å¢åŠ å…¥å£çœä»½æ–‡å­—æ ‡è¯†ï¼›
 * - [yuan]      ä¸ºå¢ƒå¤–å…¥å£æ·»åŠ çœŸå®çš„å…¥å£å±åœ°æ ‡è¯†ï¼Œå½“æœªé…ç½®æ­¤æ­¤å‚æ•°æ—¶ï¼Œåˆ™å°†å¢ƒå¤–å…¥å£ç»Ÿä¸€æ ‡è®°ä¸º [å¢ƒå¤–]ï¼Œé»˜è®¤æœªé…ç½®æ­¤å‚æ•°ï¼›
 * - [inflag]    å¢åŠ å…¥å£å›½æ——
 * 
 * è½åœ°å‚æ•°
 * - [yisp]      æ˜¾ç¤ºè½åœ°è¯¦ç»†è¿è¥å•†åç§°ï¼›
 * - [yw]        è½åœ°å½’å±åœ°ä½¿ç”¨è‹±æ–‡ç¼©å†™æ ‡è¯†ï¼Œä¸å»ºè®®ä¸å…¶ä»–å…¥å£å‚æ•°é…åˆä½¿ç”¨ï¼Œå› ä¸ºå…¶ä»–å‚æ•°APIæ²¡æœ‰è¿”å›è‹±æ–‡ï¼›
 * - [xy]        æ­¤å‚æ•°å…³é—­è½åœ°æŸ¥è¯¢ï¼Œä»…æŸ¥è¯¢å…¥å£ï¼›å¼€å¯ yisp || yw || flag å‚æ•°å xy å‚æ•°æ— æ•ˆ
 * 
 * å›¾æ ‡å‚æ•°
 * - [game]      å¢åŠ æ¸¸æˆèŠ‚ç‚¹æ ‡è¯†ï¼›
 * - [flag]      å¢åŠ å›½å®¶æˆ–åœ°åŒºçš„æ——å¸œæ ‡è¯†ï¼Œé»˜è®¤æ— æ­¤å‚æ•°ï¼›
 * - [bl]        ä¿ç•™å€ç‡æ ‡è¯†ï¼›
 * - [snone]     æ¸…ç†æŸåœ°åŒºå†…åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„åºå·ï¼›
 * 
 * åˆ†éš”ç¬¦å‚æ•°
 * - [fgf=]      è®¾ç½®å…¥å£å’Œè½åœ°ä¹‹é—´çš„åˆ†éš”ç¬¦ï¼Œé»˜è®¤ä¸ºç©ºæ ¼ï¼›
 * - [sn=]       è®¾ç½®å›½å®¶ä¸åºå·ä¹‹é—´çš„åˆ†éš”ç¬¦ï¼Œé»˜è®¤ä¸ºç©ºæ ¼ï¼›
 * - [name=]     ä¸ºèŠ‚ç‚¹æ·»åŠ æœºåœºåç§°å‰ç¼€ï¼›
 * 
 * é€šçŸ¥å‚æ•°
 * - [offtz]     å…³é—­è„šæœ¬é€šçŸ¥ï¼›
 * 
 * è§£æå‚æ•°
 * - [dnsjx]     å°†èŠ‚ç‚¹åŸŸåè§£æä¸ºIPï¼Œæ™®é€šç”¨æˆ·ä¸å»ºè®®ä½¿ç”¨ï¼›
 * 
 * é€»è¾‘å‚æ•°
 * - [bs=]       æ‰¹å¤„ç†èŠ‚ç‚¹æ•°å»ºè®®10ä¸ªå·¦å³ï¼Œå¦‚æœç»å¸¸è¯»ä¸åˆ°èŠ‚ç‚¹å»ºè®®å‡å°æ‰¹å¤„ç†ä¸ªæ•°ï¼›
 * 
 * ç¼“å­˜å‚æ•°
 * - [h=]        èŠ‚ç‚¹ç¼“å­˜æœ‰æ•ˆæœŸï¼Œå•ä½å°æ—¶ï¼Œæ—¶é—´å‚æ•°åªèƒ½äºŒé€‰ä¸€ï¼ŒLoonç”¨æˆ·ä¸éœ€å¡«å†™è¦æ­¤å‚æ•°ï¼Œè¯·è¿›å…¥Sub-Storeæ’ä»¶çš„é…ç½®ç•Œé¢è‡ªå®šä¹‰ç¼“å­˜æœ‰æ•ˆæœŸï¼›
 * - [min=]      èŠ‚ç‚¹ç¼“å­˜æœ‰æ•ˆæœŸï¼Œå•ä½åˆ†é’Ÿï¼Œæ—¶é—´å‚æ•°åªèƒ½äºŒé€‰ä¸€ï¼ŒLoonç”¨æˆ·ä¸éœ€å¡«å†™è¦æ­¤å‚æ•°ï¼Œè¯·è¿›å…¥Sub-Storeæ’ä»¶çš„é…ç½®ç•Œé¢è‡ªå®šä¹‰ç¼“å­˜æœ‰æ•ˆæœŸï¼›
 * 
 * è¶…æ—¶å‚æ•°
 * - [timeout=]  å½“æ— ä»»ä½•èŠ‚ç‚¹ç¼“å­˜æ—¶æµ‹è¯•èŠ‚ç‚¹HTTPå»¶æ—¶å…è®¸çš„æœ€å¤§è¶…æ—¶å‚æ•°ï¼Œè¶…å‡ºå…è®¸èŒƒå›´åˆ™åˆ¤å®šä¸ºæ— æ•ˆèŠ‚ç‚¹ï¼Œé»˜è®¤2000msï¼›
 * - [cd=]       å½“æœ‰ç¼“å­˜æ—¶ï¼Œä¼šå…ˆè¯»å–ç¼“å­˜ï¼Œç›´æ¥è¾“å‡ºç»“æœï¼›é»˜è®¤ [cd=]çš„å€¼ç­‰äº0ï¼Œå¾®ç›´æ¥è¯»å–ç¼“å­˜ï¼› 
 * å½“è®¾ä¸ºæ›´é«˜çš„å€¼: æ¯”å¦‚'460'åˆ™æ¯æ¬¡è¯»ç¼“å­˜éƒ½ä¼šå†æ¬¡å¤„ç†ä¹‹å‰åˆ¤å®šä¸ºè¶…æ—¶çš„èŠ‚ç‚¹,è¶…æ—¶ä¸º460ms
 *
 * å…¶ä»–å‚æ•°
 * - [debug]     è°ƒè¯•æ—¥å¿—ï¼Œæ™®é€šç”¨æˆ·ä¸å»ºè®®ä½¿ç”¨ã€‚
 * - å¼‚å¸¸ï¼šå¦‚é‡é—®é¢˜ï¼ŒLoonå¯ä»¥è¿›å…¥[é…ç½®]â†’[æŒä¹…åŒ–ç¼“å­˜]â†’[åˆ é™¤æŒ‡å®šæ•°æ®]â†’è¾“å…¥Key [sub-store-cached-script-resource]å¹¶åˆ é™¤ç¼“å­˜ã€‚ç´¯è®¡è¾“å‡ºèŠ‚ç‚¹ä¸º0ä¸ª3æ¬¡ä»¥ä¸Šå°†æ¸…ç†æ‰€æœ‰ç¼“å­˜
 * - Surgeéœ€è¦è¿›å…¥[è„šæœ¬ç¼–è¾‘å™¨]â†’å·¦ä¸‹è§’[è®¾ç½®]â†’[$persistentStore]  [sub-store-cached-script-resource]åˆ é™¤ç¼“å­˜æ•°æ®ã€‚
 */

const SUB_STORE_SCHEMA = {
  title: "CNAME",
  description: "æ ¹æ®æ¥å£è¿”å›çš„çœŸå®ç»“æœï¼Œé‡æ–°å¯¹èŠ‚ç‚¹å‘½å/å»é‡ã€‚ å¦‚ï¼šå…¥å£/è½åœ°è¯¦ç»†åœ°åŒºä¿¡æ¯",
  scope: ["Surge", "Loon"],
  author: "@Key @å¥¶èŒ¶å§ @å°ä¸€ @å¯è‰",
  updateTime: "2026-01-25 18:00:00",
  version: "4.0.0",
  params: {
    flag: {
      datatype: "boolean",
      description: "å¢åŠ è½åœ°å›½å®¶æˆ–åœ°åŒºçš„æ——å¸œæ ‡è¯†ï¼Œé»˜è®¤æ— æ­¤å‚æ•°",
      defaultValue: false,
    },
    inflag: {
      datatype: "boolean",
      description: "å¢åŠ å…¥å£å›½å®¶æˆ–åœ°åŒºçš„æ——å¸œæ ‡è¯†ï¼Œé»˜è®¤æ— æ­¤å‚æ•°",
      defaultValue: false,
    },
    xy: {
      datatype: "boolean",
      description: "å…³é—­è½åœ°æŸ¥è¯¢ï¼Œä»…æŸ¥è¯¢å…¥å£ï¼›å¼€å¯ yisp || yw || flag å‚æ•°å xy å‚æ•°æ— æ•ˆ",
      defaultValue: false,
    },
    iisp: {
      datatype: "boolean",
      description: "å¢åŠ å…¥å£è¿è¥å•†æˆ–è€…ç›´è¿æ ‡è¯†",
      defaultValue: false,
    },
    city: {
      datatype: "boolean",
      description: "å¢åŠ å…¥å£åŸå¸‚æ–‡å­—æ ‡è¯†",
      defaultValue: false,
    },
    sheng: {
      datatype: "boolean",
      description: "å¢åŠ å…¥å£çœä»½æ–‡å­—æ ‡è¯†",
      defaultValue: false,
    },
    yuan: {
      datatype: "boolean",
      description:
        "ä¸ºå¢ƒå¤–å…¥å£æ·»åŠ çœŸå®çš„å…¥å£å±åœ°æ ‡è¯†ï¼Œå½“æœªé…ç½®æ­¤æ­¤å‚æ•°æ—¶ï¼Œåˆ™å°†å¢ƒå¤–å…¥å£ç»Ÿä¸€æ ‡è®°ä¸º[å¢ƒå¤–]ï¼Œé»˜è®¤æœªé…ç½®æ­¤å‚æ•°",
      defaultValue: false,
    },
    yisp: {
      datatype: "boolean",
      description: "æ˜¾ç¤ºè½åœ°è¯¦ç»†è¿è¥å•†åç§°",
      defaultValue: false,
    },
    yw: {
      datatype: "boolean",
      description:
        "è½åœ°å½’å±åœ°ä½¿ç”¨è‹±æ–‡ç¼©å†™æ ‡è¯†ï¼Œä¸å»ºè®®ä¸å…¶ä»–å…¥å£å‚æ•°é…åˆä½¿ç”¨ï¼Œå› ä¸ºå…¶ä»–å‚æ•°APIæ²¡æœ‰è¿”å›è‹±æ–‡",
      defaultValue: false,
    },
    game: {
      datatype: "boolean",
      description: "å¢åŠ æ¸¸æˆèŠ‚ç‚¹æ ‡è¯†",
      defaultValue: false,
    },
    bl: {
      datatype: "boolean",
      description: "ä¿ç•™å€ç‡æ ‡è¯†",
      defaultValue: false,
    },
    snone: {
      datatype: "boolean",
      description: "æ¸…ç†æŸåœ°åŒºå†…åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„åºå·",
      defaultValue: false,
    },
    offtz: {
      datatype: "boolean",
      description: "å…³é—­è„šæœ¬é€šçŸ¥",
      defaultValue: false,
    },
    dnsjx: {
      datatype: "boolean",
      description: "å°†èŠ‚ç‚¹åŸŸåè§£æä¸ºIP, æ™®é€šç”¨æˆ·ä¸å»ºè®®ä½¿ç”¨",
      defaultValue: false,
    },
    debug: {
      datatype: "boolean",
      description: "è°ƒè¯•æ—¥å¿—ï¼Œæ™®é€šç”¨æˆ·ä¸å»ºè®®ä½¿ç”¨",
      defaultValue: false,
    },
    fgf: {
      datatype: "string",
      description: "è®¾ç½®å…¥å£å’Œè½åœ°ä¹‹é—´çš„åˆ†éš”ç¬¦ï¼Œé»˜è®¤ä¸ºç©ºæ ¼",
      defaultValue: " ",
    },
    sn: {
      datatype: "string",
      description: "è®¾ç½®å›½å®¶ä¸åºå·ä¹‹é—´çš„åˆ†éš”ç¬¦ï¼Œé»˜è®¤ä¸ºç©ºæ ¼",
      defaultValue: " ",
    },
    name: {
      datatype: "string",
      description: "ä¸ºèŠ‚ç‚¹æ·»åŠ æœºåœºåç§°å‰ç¼€",
      defaultValue: "",
    },
    timeout: {
      datatype: "number",
      description:
        "å½“æ— ä»»ä½•èŠ‚ç‚¹ç¼“å­˜æ—¶æµ‹è¯•èŠ‚ç‚¹HTTPå»¶æ—¶å…è®¸çš„æœ€å¤§è¶…æ—¶å‚æ•°ï¼Œè¶…å‡ºå…è®¸èŒƒå›´åˆ™åˆ¤å®šä¸ºæ— æ•ˆèŠ‚ç‚¹ï¼Œé»˜è®¤2000ms",
      defaultValue: 2000,
    },
    cd: {
      datatype: "number",
      description:
        "å½“æœ‰ç¼“å­˜æ—¶ï¼Œä¼šå…ˆè¯»å–ç¼“å­˜ï¼Œç›´æ¥è¾“å‡ºç»“æœï¼›é»˜è®¤[cd=]çš„å€¼ç­‰äº0ï¼Œå¾®ç›´æ¥è¯»å–ç¼“å­˜ï¼› å½“è®¾ä¸ºæ›´é«˜çš„å€¼: æ¯”å¦‚'460'åˆ™æ¯æ¬¡è¯»ç¼“å­˜éƒ½ä¼šå†æ¬¡å¤„ç†ä¹‹å‰åˆ¤å®šä¸ºè¶…æ—¶çš„èŠ‚ç‚¹,è¶…æ—¶ä¸º460ms",
      defaultValue: 0,
    },
    bs: {
      datatype: "number",
      description:
        "æ‰¹å¤„ç†èŠ‚ç‚¹æ•°å»ºè®®10ä¸ªå·¦å³ï¼Œå¦‚æœç»å¸¸è¯»ä¸åˆ°èŠ‚ç‚¹å»ºè®®å‡å°æ‰¹å¤„ç†ä¸ªæ•°",
      defaultValue: 10,
    },
    h: {
      datatype: "number",
      description:
        "èŠ‚ç‚¹ç¼“å­˜æœ‰æ•ˆæœŸï¼Œå•ä½å°æ—¶ï¼Œæ—¶é—´å‚æ•°åªèƒ½äºŒé€‰ä¸€ï¼ŒLoonç”¨æˆ·ä¸éœ€å¡«å†™è¦æ­¤å‚æ•°ï¼Œè¯·è¿›å…¥Sub-Storeæ’ä»¶çš„é…ç½®ç•Œé¢è‡ªå®šä¹‰ç¼“å­˜æœ‰æ•ˆæœŸ",
      defaultValue: "",
    },
    min: {
      datatype: "number",
      description:
        "èŠ‚ç‚¹ç¼“å­˜æœ‰æ•ˆæœŸï¼Œå•ä½åˆ†é’Ÿï¼Œæ—¶é—´å‚æ•°åªèƒ½äºŒé€‰ä¸€ï¼ŒLoonç”¨æˆ·ä¸éœ€å¡«å†™è¦æ­¤å‚æ•°ï¼Œè¯·è¿›å…¥Sub-Storeæ’ä»¶çš„é…ç½®ç•Œé¢è‡ªå®šä¹‰ç¼“å­˜æœ‰æ•ˆæœŸ",
      defaultValue: "",
    },
  },
};

const $ = $substore;
const iar = $arguments;
let debug = iar.debug;
const { yw, bl, iisp, xy, yisp, city, flag, inflag, game, yuan, sheng, offtz, snone: numone } = iar;
const h = iar.h ? decodeURI(iar.h) : "", min = iar.min ? decodeURI(iar.min) : "", firstN = iar.name ? decodeURI(iar.name) : "";
const { isLoon, isSurge } = $substore.env;
const dns = iar.dnsjx;
const target = isLoon ? "Loon" : isSurge ? "Surge" : undefined;
const keypr = "peedtest";
let cd = iar.cd ? iar.cd : 0, timeout = iar.timeout ? iar.timeout : 2000;
let innum = 1728e5, onen = false, Sue = false, rawtime = 1500;
const keyp = "3.s", EXPIRATION_KEY = "#sub-store-csr-expiration-time";

// åªæœ‰å½“ç”¨æˆ·æ˜ç¡®æŒ‡å®šäº†hæˆ–minå‚æ•°æ—¶ï¼Œæ‰æ›´æ–°ç¼“å­˜æœ‰æ•ˆæœŸ
if (min !== "") {
  Sue = true;
  innum = parseInt(min, 10) * 6e4;
  $.write(JSON.stringify(innum), EXPIRATION_KEY);
} else if (h !== "") {
  Sue = true;
  innum = parseInt(h, 10) * 36e5;
  $.write(JSON.stringify(innum), EXPIRATION_KEY);
}

// è¯»å–ç¼“å­˜æœ‰æ•ˆæœŸï¼Œä¸è¦†ç›–ç”¨æˆ·ä¹‹å‰çš„è®¾ç½®
let TIMEDKEY = $.read(EXPIRATION_KEY);
// å¦‚æœç¼“å­˜æœ‰æ•ˆæœŸä¸å­˜åœ¨ï¼Œè®¾ç½®é»˜è®¤å€¼
if (!TIMEDKEY) {
  TIMEDKEY = JSON.stringify(innum);
  $.write(TIMEDKEY, EXPIRATION_KEY);
}
let inapi = 0;

// é…ç½®å¸¸é‡
const CONFIG = {
  BATCH_SIZE: iar.bs || 10,
  TIMEOUT: timeout,
  CACHE_TIMEOUT: cd,
  RETRY_MAX: 2,
  CACHE_KEY_PREFIX: {
    ALI: "al",
    SP: "sc",
    IN: "in",
    OUT: "out"
  }
};

// V2ç‰ˆæœ¬ç¼“å­˜æœºåˆ¶
let apiRead = 0, apiw = 0;
const oaMap = new Map();
const alMap = new Map();
const spMap = new Map();
const iaMap = new Map();

/**
 * ä¸»å‡½æ•°å…¥å£
 */
async function operator(e = [], env) {
  const startTime = new Date();
  const support = isLoon || isSurge;
  
  // åˆå§‹åŒ–å˜é‡
  let tzname = "", subcoll = "", x = false, xys = false;
  if (env?.source?.[e?.[0]?.subName]) x = true;
  if (env?.source?._collection?.name) xys = true;
  
  // ç¡®å®šè®¢é˜…ä¿¡æ¯
  if (x && xys) {
    tzname = env.source._collection.name + ": [" + env.source._collection.subscriptions + "]";
    subcoll = "ç»„åˆè®¢é˜…å†…å•æ¡è®¢é˜…åŠ äº†è„šæœ¬, è¾“å‡ºç»„åˆè®¢é˜…";
  } else if (x) {
    tzname = env.source[e[0].subName].name;
    subcoll = "å•æ¡è®¢é˜…è„šæœ¬";
  } else {
    tzname = env.source._collection.name;
    subcoll = "ç»„åˆè®¢é˜…è„šæœ¬";
  }
  
  // æ—¥å¿—å‡½æ•°
  function klog(...arg) {
    console.log('[CNAME] ' + subcoll + tzname + " : " + arg);
  }
  
  // æ£€æŸ¥èŠ‚ç‚¹æ•°é‡
  if (e.length < 1) {
    $.notify(subcoll + tzname, "è®¢é˜…æ— èŠ‚ç‚¹", "");
    return e;
  }
  
  // æ£€æŸ¥ç¼“å­˜æ˜¯å¦å¯ç”¨
  if (typeof scriptResourceCache === "undefined") return e;
  
  const ein = e.length;
  const eins = ein / 2;
  
  klog(`å¼€å§‹å¤„ç†èŠ‚ç‚¹: ${ein} ä¸ª`);
  klog(`æ‰¹å¤„ç†èŠ‚ç‚¹æ•°: ${CONFIG.BATCH_SIZE} ä¸ª`);
  klog(`è®¾å®šapiè¶…æ—¶: ${zhTime(timeout)}`);
  klog(`æœ‰ç¼“apiè¶…æ—¶: ${zhTime(cd)}`);
  
  // æ£€æŸ¥ç¼“å­˜æ•°é‡
  let cachen = 0;
  for (const pk of e) {
    const id = getid(pk);
    if (scriptResourceCache.get(id)) {
      cachen++;
      if (cachen > eins && !onen) {
        klog(`æ£€æŸ¥ç¼“å­˜æ•°é‡: ${cachen}/${ein} ä¸ª`);
        rawtime = timeout;
        timeout = cd;
        onen = true;
        break;
      }
    }
  }
  
  // æ˜¾ç¤ºé€šçŸ¥
  if (!onen && !offtz) {
    $.notify(subcoll + tzname, `å¼€å§‹å¤„ç†èŠ‚ç‚¹: ${ein} ä¸ª æ‰¹å¤„ç†æ•°é‡: ${CONFIG.BATCH_SIZE} ä¸ª`, "è¯·ç­‰å¾…å¤„ç†å®Œæ¯•åå†æ¬¡ç‚¹å‡»é¢„è§ˆ");
  }
  
  // V2ç‰ˆæœ¬é‡è¯•é€»è¾‘
  let retryi = 0;
  do {
    const processedNodes = await processNodesBatch(e, CONFIG.BATCH_SIZE, klog, subcoll, tzname);
    
    // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰èŠ‚ç‚¹è½åœ°IPç›¸åŒ
    if (processedNodes.length > 3 && isSurge) {
      const allsame = processedNodes.every((value, index, arr) => value._outips === arr[0]._outips);
      if (allsame) {
        klog(`æœªä½¿ç”¨å¸¦æŒ‡å®šèŠ‚ç‚¹åŠŸèƒ½çš„ SubStore, æˆ–æ‰€æœ‰èŠ‚ç‚¹è½åœ°IPç›¸åŒ`);
        $.notify('CNAMEï¼šç‚¹å‡»ä»¥å®‰è£…å¯¹åº”ç‰ˆæœ¬', 'æœªä½¿ç”¨å¸¦æŒ‡å®šèŠ‚ç‚¹åŠŸèƒ½çš„ SubStoreï¼Œæˆ–æ‰€æœ‰èŠ‚ç‚¹è½åœ°IPç›¸åŒ', '', {
          url: "https://raw.githubusercontent.com/sub-store-org/Sub-Store/master/config/Surge-ability.sgmodule",
        });
        return processedNodes;
      }
    }
    
    // V2ç‰ˆæœ¬å»é‡é€»è¾‘
    !xy && (e = removels(e));
    
    // å¤„ç†é‡è¯•
      if (inapi >= 1 && retryi < CONFIG.RETRY_MAX) {
        retryi++;
        timeout = rawtime;
        onen = false;
        // V2ç‰ˆæœ¬é‡è¯•æ—¶æ¸…ç©ºæ‰€æœ‰Mapç¼“å­˜
        spMap.clear();
        alMap.clear();
        iaMap.clear();
        oaMap.clear();
        klog(`é‡è¯•ä¸­... ç¬¬ ${retryi} æ¬¡`);
      } else {
        retryi = CONFIG.RETRY_MAX;
      }
  } while (retryi < 2);
  
  // æœ€ç»ˆå¤„ç†
  !xy && (e = removeqc(e));
  e = jxh(e);
  numone && (e = onee(e));
  
  const endTime = new Date();
  const timeDiff = endTime.getTime() - startTime.getTime();
  const eout = e.length;
  
  // è¾“å‡ºæ—¥å¿—
  if (dns) klog(`dnsè§£æåå…±: ${eout} ä¸ª`);
  apiRead > 0 && klog(`è¯»å–apiç¼“å­˜: ${apiRead} ä¸ª`);
  apiw > 0 && klog(`å†™å…¥apiç¼“å­˜: ${apiw} ä¸ª`);
  klog(`å¤„ç†å®Œåå‰©ä½™: ${eout} ä¸ª`);
  
  // ç¼“å­˜è¿‡æœŸæ—¶é—´
  let Pushtd = "";
  if (isLoon) {
    const intimed = $.read("#èŠ‚ç‚¹ç¼“å­˜æœ‰æ•ˆæœŸ");
    const loonkkk = {"1åˆ†é’Ÿ":6e4,"5åˆ†é’Ÿ":3e5,"10åˆ†é’Ÿ":6e5,"30åˆ†é’Ÿ":18e5,"1å°æ—¶":36e5,"2å°æ—¶":72e5,"3å°æ—¶":108e5,"6å°æ—¶":216e5,"12å°æ—¶":432e5,"24å°æ—¶":864e5,"48å°æ—¶":1728e5,"72å°æ—¶":2592e5,"å‚æ•°ä¼ å…¥":"innums"};
    const loontd = loonkkk[intimed] || 1728e5;
    const readt = scriptResourceCache.gettime(e[0]?.keyrk || getid(e[0]));
    const nt = new Date().getTime();
    Pushtd = `, ${zhTime(parseInt(readt, 10) - nt + parseInt(loontd, 10))}åè¿‡æœŸ \n`;
    klog("ç¼“å­˜è¿‡æœŸæ—¶é—´: " + intimed + ", è¿˜å‰©" + Pushtd.replace(/,|\n/g, ""));
  } else {
    const readt = scriptResourceCache.gettime(e[0]?.keyrk || getid(e[0]));
    const nt = new Date().getTime();
    Pushtd = `, ${zhTime(parseInt(readt, 10) - nt + parseInt(TIMEDKEY, 10))}åè¿‡æœŸ \n`;
    klog("ç¼“å­˜è¿‡æœŸæ—¶é—´: " + zhTime(TIMEDKEY) + ", è¿˜å‰©" + Pushtd.replace(/,|\n/g, ""));
  }
  
  klog(`æ­¤æ–¹æ³•æ€»ç”¨æ—¶: ${zhTime(timeDiff)}\n----For New CNAME----\n\n\n\n`);
  
  // æ˜¾ç¤ºé€šçŸ¥
  const readklog = apiRead ? `è¯»å–ç¼“å­˜:${apiRead} ` : "";
  const writeklog = apiw ? `å†™å…¥ç¼“å­˜:${apiw}, ` : "";
  const Push = (eout === ein && eout === 0) ? "" : (eout === ein ? "å…¨éƒ¨é€šè¿‡æµ‹è¯•, " : "å»é™¤æ— æ•ˆèŠ‚ç‚¹åæœ‰" + eout + "ä¸ª, ");
  
  if (!offtz) {
    $.notify(
      `${subcoll}${tzname} å…±${ein}ä¸ªèŠ‚ç‚¹`,
      "",
      `${writeklog}${readklog}${Pushtd}${Push}ç”¨æ—¶:${zhTime(timeDiff)}`
    );
  }
  
  return e;
}

/**
 * æ‰¹é‡å¤„ç†èŠ‚ç‚¹
 */
async function processNodesBatch(nodes, batchSize, klog, subcoll, tzname) {
  const results = [];
  const nodeCount = nodes.length;
  
  for (let i = 0; i < nodeCount; i += batchSize) {
    const batch = nodes.slice(i, i + batchSize);
    
    try {
      const batchResults = await Promise.all(
        batch.map(async (pk) => {
          return await processSingleNode(pk);
        })
      );
      
      // æ”¶é›†æˆåŠŸç»“æœ
      batchResults.forEach(result => {
        if (result) {
          results.push(result);
        }
      });
    } catch (err) {
      debug && klog(`æ‰¹å¤„ç†å¤±è´¥: ${err.message}`);
      // ç»§ç»­å¤„ç†ä¸‹ä¸€æ‰¹ï¼Œä¸ä¸­æ–­æ•´ä¸ªæµç¨‹
    }
    
    // æ˜¾ç¤ºè¿›åº¦
    const processed = Math.min(i + batchSize, nodeCount);
    klog(`å¤„ç†è¿›åº¦${processed}/${nodeCount}`);
    
    // è¿›åº¦é€šçŸ¥
    if (!onen && !offtz && (nodeCount > processed * 2)) {
      if (processed >= (nodeCount / 3) && processed < (nodeCount * 2 / 3)) {
        $.notify(subcoll + tzname, `å¤„ç†è¿›åº¦${processed}/${nodeCount}`, "è€å¿ƒç­‰å¾…, è¯·å‹¿é‡å¤ç‚¹å‡»é¢„è§ˆ...");
      }
    }
    
    // éç¼“å­˜æ¨¡å¼ä¸‹æ·»åŠ éšæœºå»¶è¿Ÿ
    if (!onen) {
      await sleep(GRa());
    }
  }
  
  // æ›´æ–°åŸå§‹èŠ‚ç‚¹æ•°ç»„
  nodes.splice(0, nodes.length, ...results);
  return nodes;
}

/**
 * å¤„ç†å•ä¸ªèŠ‚ç‚¹
 */
async function processSingleNode(pk) {
  let Yserver = pk.server, luodi = "", inQcip = "", nxx = "", adflag = "", OGame = "", Oisp = "", Oispflag = "", Osh = "", Oct = "", zhi = "", yuanisp = "", isCN = false, v4 = false, v6 = false, isNoAli = false;
  
  // åŸŸåè§£æ
  let inServer = await AliD(Yserver);
  debug && delog(inServer);
  
  if (inServer === "keyn") {
    isNoAli = true;
    inServer = Yserver;
  } else {
    pk.keyrk = inServer;
    // æ›´å®½æ¾çš„IPv4å’ŒIPv6æ­£åˆ™è¡¨è¾¾å¼
    if (/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(inServer)) {
      v4 = true;
    } else if (/^([0-9a-fA-F]{0,4}:){0,7}[0-9a-fA-F]{0,4}$/.test(inServer)) {
      v6 = true;
    }
  }
  
  // è½åœ°æŸ¥è¯¢
  let btip = true, outu = "", outips = "";
  if (!xy || yisp || yw || flag) {
    const outip = await OUTIA(pk);
    let { country: outUsq, countryCode: outUs, city: outCity, query: outQuery, isp: outisp } = outip;
    
    if (yisp) {
      yuanisp = FGFS + outisp;
    }
    
    debug && (pk.keyoutld = outip);
    debug && delog("è½åœ°ä¿¡æ¯ " + JSON.stringify(outip));
    
    outu = outUs;
    outips = outQuery;
    luodi = (outUsq === "ä¸­å›½") ? outCity : (yw ? outUs : outUsq);
    btip = outQuery !== inServer;
    pk._outips = outQuery;
  }
  
  // å…¥å£æŸ¥è¯¢
  if (btip || xy) {
    if (!isNoAli || v4) {
      const spkey = await SPEC(inServer);
      let { country: inSpCn, regionName: inSpSheng, city: inSpCity, isp: inSpIsp, ip: inSpIp, countryCode: inCode } = spkey;
      
      inflag && (pk._iflag = getflag(inCode));
      debug && (pk.keyinsp = spkey);
      
      isCN = inSpCn === "ä¸­å›½";
      inQcip = inServer;
      
      const keycm = {ç”µä¿¡:"ğŸ…³", è”é€š:"ğŸ…»", ç§»åŠ¨: "ğŸ†ˆ",å¹¿ç”µ:"ğŸ…¶"};
      if (isCN) {
        debug && delog("å›½å†…å…¥å£ " + JSON.stringify(spkey));
        
        if (iisp && flag) {
          inSpIsp = inSpIsp.replace(/ä¸­å›½/g, "");
          flag && (Oispflag = keycm.hasOwnProperty(inSpIsp) ? keycm[inSpIsp] : "ğŸ…²");
        } else if (iisp) {
          Oisp = /ç”µä¿¡|è”é€š|ç§»åŠ¨|å¹¿ç”µ/.test(inSpIsp) ? inSpIsp.replace(/ä¸­å›½/g, "") : "ä¼ä¸š";
        }
        
        (inSpSheng === inSpCity) && (inSpCity = "");
        
        if (sheng && city) {
          Osh = inSpSheng; Oct = inSpCity;
        } else if (sheng) {
          Osh = inSpSheng;
        } else if (city) {
          Oct = inSpCity ? inSpCity : inSpSheng;
        }
      }
    }
    
    if (isNoAli || v6 || !isCN) {
      const inip = await INIA(Yserver);
      let { country: inUsq, city: inCity, query: inQuery, regionName: inIpSh, countryCode: inaCode } = inip;
      
      inflag && (pk._iflag = getflag(inaCode));
      debug && (pk.keyinipapi = inip);
      debug && delog("ipapiå…¥å£ " + JSON.stringify(inip));
      
      inQcip = inQuery;
      
      if (inUsq === "ä¸­å›½") {
        (/[a-zA-Z]/.test(inCity)) && (inCity = inIpSh);
        (inCity === inIpSh) && (inIpSh = "");
        
        if (sheng && city) {
          Osh = inIpSh; Oct = inCity;
        } else if (sheng) {
          Osh = inIpSh;
        } else if (city) {
          Oct = inCity ? inCity : inIpSh;
        }
        
        flag && (Oispflag = "ğŸ…²");
      } else {
        if (inQuery === outips) {
          flag && (Oispflag = "ğŸ†‰");
          (sheng || city || iisp) && (zhi = "ç›´è¿");
        } else if (yuan) {
          flag && (Oispflag = "ğŸ…²");
          (sheng || city || iisp) && (zhi = inUsq);
        } else {
          flag && (Oispflag = "ğŸ†‡");
          (sheng || city || iisp) && (zhi = "å¢ƒå¤–");
        }
      }
    }
  } else {
    flag && (Oispflag = "ğŸ†‰");
    (sheng || city || iisp) && (zhi = "ç›´è¿");
  }
  
  // å¤„ç†å›½æ——
  flag && (adflag = getflag(outu));
  
  // å¤„ç†æ¸¸æˆæ ‡è¯†
  game && (OGame = /game|æ¸¸æˆ/i.test(pk.name) ? (flag ? "ğŸ®" : FGF + "Game") : OGame);
  
  // å¤„ç†å€ç‡
  if (bl) {
    const match = pk.name.match(/((å€ç‡|X|x|Ã—)\D?((\d\.)?\d+)\D?)|((\d\.)?\d+)(å€|X|x|Ã—)/);
    if (match) {
      const matchVa = match[0].match(/(\d[\d.]*)\D*/)[0].trim();
      if (matchVa !== "1") {
        nxx = XHFGF + matchVa + "X";
      }
    }
  }
  
  // ç”ŸæˆèŠ‚ç‚¹åç§°
  const FGF = iar.fgf == undefined ? " " : decodeURI(iar.fgf);
  const FGFS = FGF;
  const XHFGF = iar.sn == undefined ? " " : decodeURI(iar.sn);
  
  (!iisp && !city && !sheng && !xy && !inflag) && (Oispflag = "", FGF = "");
  
  let keyover = [
    firstN, 
    pk._iflag || "", 
    Oispflag, 
    Osh, 
    Oct, 
    Oisp, 
    zhi, 
    FGF, 
    adflag, 
    luodi, 
    OGame, 
    nxx, 
    yuanisp
  ].filter(ki => ki !== "");
  
  let overName = keyover.join("");
  xy && (overName = (pk._iflag || "") + overName + FGF + pk.name);
  
  // åº”ç”¨DNSè§£æ
  dns && (pk.server = inQcip);
  
  // è®¾ç½®èŠ‚ç‚¹åç§°
  pk.name = overName;
  inflag && !pk._iflag && (pk.name = getflag(outu) + overName);
  
  // V2ç‰ˆæœ¬èŠ‚ç‚¹éªŒè¯ - å®½æ¾éªŒè¯
  pk.qc = inQcip + outips;
  
  return pk;
}

// å·¥å…·å‡½æ•°
function getid(e) { return FNV1a(`${e.server}-${e.port}-${e.type}`); }
function getaliid(e) { return FNV1a(`${CONFIG.CACHE_KEY_PREFIX.ALI}-${e}`); }
function getspcn(e) { return FNV1a(`${CONFIG.CACHE_KEY_PREFIX.SP}-${e}`); }
function getinid(e) { return FNV1a(`${CONFIG.CACHE_KEY_PREFIX.IN}-${e}`); }
function getoutid(e) { return getid(e); }

function delog(...arg) { if (debug) { console.log('[CNAME] :' + arg); } }
function sleep(e) { return new Promise((t) => setTimeout(t, e)); }
function GRa() { return Math.floor(Math.random() * (500 - 50 + 1) + 50); }

// å›½æ——ç”Ÿæˆå‡½æ•°
function getflag(e) {
  const t = e.toUpperCase().split("").map((e) => 127397 + e.charCodeAt());
  return String.fromCodePoint(...t).replace(/ğŸ‡¹ğŸ‡¼/g, "ğŸ‡¨ğŸ‡³");
}

// æ—¶é—´æ ¼å¼åŒ–å‡½æ•°
function zhTime(e) {
  e = e.toString().replace(/-/g, "");
  if (e < 1e3) {
    return `${Math.round(e)}æ¯«ç§’`;
  } else if (e < 6e4) {
    return `${Math.round(e / 1e3)}ç§’`;
  } else if (e < 36e5) {
    return `${Math.round(e / 6e4)}åˆ†é’Ÿ`;
  } else {
    return `${Math.round(e / 36e5)}å°æ—¶`;
  }
}

// V2ç‰ˆæœ¬ - è½åœ°IPæŸ¥è¯¢
async function OUTIA(e) {
  const t = getid(e);
  if (oaMap.has(t)) return oaMap.get(t);
  const cached = scriptResourceCache.get(t);
  if (cached) {
    apiRead++;
    return cached;
  } else {
    inapi++;
  }
  const maxRE = 2;
  const url = `http://ip-api.com/json?lang=zh-CN&fields=status,message,country,countryCode,city,query,isp`;
  const getHttp = async (reTry) => {
    try {
      let r = ProxyUtils.produce([e], target);
      const response = await Promise.race([
        $.http.get({ url: url, node: r, "policy-descriptor": r }),
        new Promise((_, reject) => setTimeout(() => reject(new Error("timeout-OUTIA")), timeout) ),
      ]);
      const data = JSON.parse(response.body);
      if (data.status === "success") {
        scriptResourceCache.set(t, data);
        return data;
      } else {
        throw new Error(data.message);
      }
    } catch (error) {
      if (reTry < maxRE) {
        await sleep(GRa());
        delog(e.name + "-> [outipApiè¶…æ—¶æŸ¥è¯¢æ¬¡æ•°] " + reTry);
        return getHttp(reTry + 1);
      } else {
        throw error;
      }
    }
  };
  const resGet = new Promise((resolve, reject) => {
    if (cd < 1 && onen) {
      // å½“æœ‰ç¼“å­˜ä¸”ä¸éœ€è¦é‡æ–°æµ‹è¯•æ—¶ï¼Œç›´æ¥resolve
      resolve(scriptResourceCache.get(t));
      return;
    }
    getHttp(1)
      .then((data) => {
        apiw++;
        resolve(data);
      })
      .catch(reject);
  });
  oaMap.set(t, resGet);
  return resGet;
}

// V2ç‰ˆæœ¬ - åŸŸåè§£æ
async function AliD(e) {
  const ti = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$|^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/.test(
    e
  );
  if (ti) return e;
  const t = getaliid(e);
  if (alMap.has(t)) return alMap.get(t);
  const cached = scriptResourceCache.get(t);
  if (cached) {
    apiRead++;
    return cached;
  } else {
    inapi++;
  }
  const maxRE = 2;
  let alip = Math.random() < 0.5 ? '223.5.5.5' : '223.6.6.6';
  const url = `https://${alip}/resolve?name=${e}&type=A&short=1`;
  const getHttp = async (reTry) => {
    try {
      const response = await Promise.race([
        $.http.get({ url: url }),
        new Promise((_, reject) => setTimeout(() => reject(new Error("timeout-AliD")), timeout) ),
      ]);
      const resdata = JSON.parse(response.body);
      if (resdata.length > 0) {
        scriptResourceCache.set(t, resdata[0]);
        return resdata[0];
      } else {
        return "keyn";
      }
    } catch (error) {
      if (reTry < maxRE) {
        await sleep(GRa());
        delog(e + " [->Aliè¶…æ—¶æŸ¥è¯¢æ¬¡æ•°] " + reTry);
        return getHttp(reTry + 1);
      } else {
        throw error;
      }
    }
  };
  const resGet = new Promise((resolve, reject) => {
    if (cd < 1 && onen) {
      // å½“æœ‰ç¼“å­˜ä¸”ä¸éœ€è¦é‡æ–°æµ‹è¯•æ—¶ï¼Œç›´æ¥resolve
      resolve(scriptResourceCache.get(t));
      return;
    }
    getHttp(1)
      .then((data) => {
        resolve(data);
      })
      .catch(reject);
  });
  alMap.set(t, resGet);
  return resGet;
}

// V2ç‰ˆæœ¬ - å›½å†…å…¥å£IPæŸ¥è¯¢
async function SPEC(e) {
  const n = getspcn(e);
  if (spMap.has(n)) return spMap.get(n);
  const cached = scriptResourceCache.get(n);
  if (cached) {
    apiRead++;
    return cached;
  } else {
    inapi++;
  }
  const maxRE = 2;
  const url = `https://api-v${keyp}${keypr}.cn/ip?ip=${e}`;
  const getHttp = async (reTry) => {
    try {
      const response = await Promise.race([
        $.http.get({ url: url }),
        new Promise((_, reject) => setTimeout(() => reject(new Error("timeout-SPEC")), timeout) ),
      ]);
      const resdata = JSON.parse(response.body);
      delog(resdata);
      if (resdata.data) {
        const { country: e, province: o, city: r, isp: i, ip: c, countryCode: k, } = resdata.data;
        const a = { country: e, regionName: o, city: r, isp: i, ip: c, countryCode: k, };
        delog("å†™å…¥");
        scriptResourceCache.set(n, a);
        return a;
      } else {
        throw new Error(resdata.message);
      }
    } catch (error) {
      if (reTry < maxRE) {
        await sleep(GRa());
        delog(e + "-> [SPè¶…æ—¶æŸ¥è¯¢æ¬¡æ•°] " + reTry);
        return getHttp(reTry + 1);
      } else {
        throw error;
      }
    }
  };
  const resGet = new Promise((resolve, reject) => {
    if (cd < 1 && onen) return resGet;
    getHttp(1)
      .then((data) => {
        resolve(data);
      })
      .catch(reject);
  });
  spMap.set(n, resGet);
  return resGet;
}

// V2ç‰ˆæœ¬ - å›½å¤–å…¥å£IPæŸ¥è¯¢
async function INIA(e) {
  const t = getinid(e);
  if (iaMap.has(t)) return iaMap.get(t);
  const cached = scriptResourceCache.get(t);
  if (cached) {
    apiRead++;
    return cached;
  } else {
    inapi++;
  }
  const maxRE = 2;
  const url = `http://ip-api.com/json/${e}?lang=zh-CN&fields=status,message,country,city,query,regionName,countryCode`;
  const getHttp = async (reTry) => {
    try {
      delog(url);
      const response = await Promise.race([
        $.http.get({ url: url }),
        new Promise((_, reject) => setTimeout(() => reject(new Error("timeout-INIA")), timeout) ),
      ]);
      const data = JSON.parse(response.body);
      if (data.status === "success") {
        scriptResourceCache.set(t, data);
        return data;
      } else {
        throw new Error(data.message);
      }
    } catch (error) {
      if (reTry < maxRE) {
        await sleep(GRa());
        delog(e + "-> [inipApiè¶…æ—¶æŸ¥è¯¢æ¬¡æ•°] " + reTry);
        return getHttp(reTry + 1);
      } else {
        throw error;
      }
    }
  };
  const resGet = new Promise((resolve, reject) => {
    if (cd < 1 && onen) return resGet;
    getHttp(1)
      .then((data) => {
        resolve(data);
      })
      .catch(reject);
  });
  iaMap.set(t, resGet);
  return resGet;
}

// V2ç‰ˆæœ¬ - èŠ‚ç‚¹å»é‡å‡½æ•°
function removels(e) {
  const t = new Set();
  const n = [];
  for (const s of e) {
    // ç¡®ä¿qcå­˜åœ¨ä¸”ä¸ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œæˆ–è€…ä½¿ç”¨èŠ‚ç‚¹è‡ªèº«ä½œä¸ºå»é‡ä¾æ®
    const qcValue = s.qc || `${s.server}-${s.port}-${s.type}`;
    if (!t.has(qcValue)) {
      t.add(qcValue);
      n.push(s);
    }
  }
  return n;
}

function removeqc(e) {
  const t = new Set();
  const n = [];
  for (const s of e) {
    // ç¡®ä¿qcå­˜åœ¨ä¸”ä¸ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œæˆ–è€…ä½¿ç”¨èŠ‚ç‚¹è‡ªèº«ä½œä¸ºå»é‡ä¾æ®
    const qcValue = s.qc || `${s.server}-${s.port}-${s.type}`;
    if (!t.has(qcValue)) {
      t.add(qcValue);
      const clone = { ...s };
      delete clone.qc;
      n.push(clone);
    }
  }
  return n;
}

// èŠ‚ç‚¹é‡æ–°ç¼–å·
function jxh(e) {
  const t = e.reduce((acc, curr) => {
    // ç§»é™¤åç§°æœ«å°¾çš„æ•°å­—ç¼–å·ï¼Œä¿ç•™å…¶ä»–å†…å®¹
    const key = curr.name.replace(/\s*\d+$/, "");
    if (!acc[key]) {
      acc[key] = [];
    }
    acc[key].push(curr);
    return acc;
  }, {});
  
  const result = [];
  for (const key in t) {
    const nodes = t[key];
    nodes.forEach((node, index) => {
      const newName = `${key}${XHFGF}${(index + 1).toString().padStart(2, "0")}`;
      result.push({ ...node, name: newName });
    });
  }
  
  return result;
}

// æ¸…ç†å•èŠ‚ç‚¹åºå·
function onee(e) {
  const t = e.reduce((acc, curr) => {
    // ç§»é™¤åç§°æœ«å°¾çš„æ•°å­—ç¼–å·ï¼Œä¿ç•™å…¶ä»–å†…å®¹
    const key = curr.name.replace(/[^A-Za-z0-9\u00C0-\u017F\u4E00-\u9FFF]+\d+$/, "");
    if (!acc[key]) {
      acc[key] = [];
    }
    acc[key].push(curr);
    return acc;
  }, {});
  
  for (const key in t) {
    if (t[key].length === 1 && t[key][0].name.endsWith("01")) {
      // æ¸…ç†æœ«å°¾çš„ "01" åºå·
      t[key][0].name = t[key][0].name.replace(/01$/, "");
    }
  }
  
  // ç¡®ä¿è¿”å›çš„æ˜¯æ‰å¹³æ•°ç»„
  return Object.values(t).flat();
}

// FNV-1a å‡½æ•° - æ›¿ä»£ MD5ï¼Œæ€§èƒ½æå‡çº¦4å€
function FNV1a(str) {
    let hash = 0x811c9dc5;
    const prime = 0x01000193;
    for (let i = 0; i < str.length; i++) {
        hash ^= str.charCodeAt(i);
        hash = Math.imul(hash, prime);
    }
    return (hash >>> 0).toString(16).padStart(8, '0');
}
