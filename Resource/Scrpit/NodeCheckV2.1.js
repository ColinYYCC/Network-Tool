/**
 * @Sub-Store-Page
 * CNAME æ¥å£æŸ¥è¯¢å»é‡/é‡å‘½å 2023-11-16 20:34:08
 * - å…¥å£æŸ¥è¯¢[å›½å†…spapi è¯†åˆ«åˆ°å›½å¤–ä¸ºip-api] è½åœ°æŸ¥è¯¢[ip-api]
 * - æ ¹æ®æ¥å£è¿”å›çš„çœŸå®ç»“æœï¼Œé‡æ–°å¯¹èŠ‚ç‚¹å‘½åã€‚
 * - æ·»åŠ å…¥å£åŸå¸‚ã€è½åœ°å›½å®¶æˆ–åœ°åŒºã€å›½å†…è¿è¥å•†ä¿¡æ¯ï¼Œå¹¶å¯¹è¿™äº›æ•°æ®åšæŒä¹…åŒ–ç¼“å­˜ï¼ˆ48å°æ—¶æœ‰æ•ˆæœŸï¼‰ï¼Œå‡å°‘APIè¯·æ±‚æ¬¡æ•°ï¼Œæé«˜è¿è¡Œæ•ˆç‡ã€‚
 * - ä»…å…¼å®¹ Surge, Loon å®¢æˆ·ç«¯ã€‚
 * - Surge éœ€è¦å›ºå®šå¸¦ ability å‚æ•°ç‰ˆæœ¬ã€‚
 * ç‰¹åˆ«è¯´æ˜ï¼š
 * - ç¬¦å·ï¼šğŸ…³ç”µä¿¡ ğŸ…»è”é€š ğŸ†ˆç§»åŠ¨ ğŸ…¶å¹¿ç”µ ğŸ…²å…¬å¸ ğŸ†‰ç›´è¿ ğŸ®æ¸¸æˆ
 * - é¦–æ¬¡è¿è¡Œæˆ–è€…åœ¨æ²¡æœ‰ç¼“å­˜çš„æƒ…å†µä¸‹ä¼šé€šçŸ¥è¿›åº¦
 * - æ— å‚æ•°æ—¶çš„èŠ‚ç‚¹å‘½åæ ¼å¼: "ç¾å›½ 01"
 * - 1. å®˜æ–¹é»˜è®¤ç‰ˆ(ç›®å‰ä¸å¸¦ ability å‚æ•°, ä¸ä¿è¯ä»¥åä¸ä¼šæ”¹åŠ¨): ã€‹https://raw.githubusercontent.com/sub-store-org/Sub-Store/master/config/Surge.sgmodule
 *
 * - 2. å›ºå®šå¸¦ ability å‚æ•°ç‰ˆæœ¬,å¯èƒ½ä¼šçˆ†å†…å­˜, å¦‚æœéœ€è¦ä½¿ç”¨æŒ‡å®šèŠ‚ç‚¹åŠŸèƒ½ ä¾‹å¦‚ [åŠ å›½æ——è„šæœ¬æˆ–è€…cnameè„šæœ¬] è¯·ä½¿ç”¨æ­¤å¸¦ ability å‚æ•°ç‰ˆæœ¬: https://raw.githubusercontent.com/sub-store-org/Sub-Store/master/config/Surge-ability.sgmodule
 *
 * - 3. å›ºå®šä¸å¸¦ ability å‚æ•°ç‰ˆæœ¬ï¼šhttps://raw.githubusercontent.com/sub-store-org/Sub-Store/master/config/Surge-Noability.sgmodule
 *
 * - å‚æ•°å¿…é¡»ä»¥"#"å¼€å¤´ï¼Œå¤šä¸ªå‚æ•°ä½¿ç”¨"&"è¿æ¥ï¼Œä¾‹å¦‚ https://github.com/Keywos/rule/raw/main/cname.js#city&iisp&name=Name
 * - ä»¥ä¸‹æ˜¯æ­¤è„šæœ¬æ”¯æŒçš„å‚æ•°ï¼Œå¿…é¡»ä»¥"#"å¼€å¤´ï¼Œå¤šä¸ªå‚æ•°ä½¿ç”¨"&"è¿æ¥ï¼Œéœ€è¦ä¼ å…¥å‚æ•°çš„è¯ç”¨ "=" ä¾‹å¦‚ "name=ä¸€å…ƒ" å‚è€ƒä¸Šè¿°åœ°å€ä¸ºä¾‹ä½¿ç”¨å‚æ•°ã€‚
 * - æ— å‚æ•°æ—¶çš„èŠ‚ç‚¹å‘½åæ ¼å¼: "ç¾å›½ 01"ï¼Œå¦‚æœ [å…¥å£IPæˆ–å›½å®¶]æˆ– [è½åœ°IPæˆ–å›½å®¶]ä¸€æ ·åˆ™ä¸º "ç›´è¿ å¾·å›½ 01" 
 * - é¦–æ¬¡è¿è¡Œæˆ–è€…åœ¨æ²¡æœ‰ç¼“å­˜çš„æƒ…å†µä¸‹ä¼šé€šçŸ¥è¿›åº¦
 * 
 * 
 * å…¥å£å‚æ•°
 * - [iisp]      å¢åŠ å…¥å£è¿è¥å•†æˆ–è€…ç›´è¿æ ‡è¯†ï¼›
 * - [city]      å¢åŠ å…¥å£åŸå¸‚æ–‡å­—æ ‡è¯†ï¼›
 * - [sheng]     å¢åŠ å…¥å£çœä»½æ–‡å­—æ ‡è¯†ï¼›
 * - [yuan]      ä¸ºå¢ƒå¤–å…¥å£æ·»åŠ çœŸå®çš„å…¥å£å±åœ°æ ‡è¯†ï¼Œå½“æœªé…ç½®æ­¤æ­¤å‚æ•°æ—¶ï¼Œåˆ™å°†å¢ƒå¤–å…¥å£ç»Ÿä¸€æ ‡è®°ä¸º [å¢ƒå¤–]ï¼Œé»˜è®¤æœªé…ç½®æ­¤å‚æ•°ï¼›
 * - [inflag]    å¢åŠ å…¥å£å›½æ——
 * 
 * è½åœ°å‚æ•°
 * - [yisp]      æ˜¾ç¤ºè½åœ°è¯¦ç»†è¿è¥å•†åç§°ï¼›
 * - [yw]        è½åœ°å½’å±åœ°ä½¿ç”¨è‹±æ–‡ç¼©å†™æ ‡è¯†ï¼Œä¸å»ºè®®ä¸å…¶ä»–å…¥å£å‚æ•°é…åˆä½¿ç”¨ï¼Œå› ä¸ºå…¶ä»–å‚æ•°APIæ²¡æœ‰è¿”å›è‹±æ–‡ï¼›
 * - [xy]        æ­¤å‚æ•°å…³é—­è½åœ°æŸ¥è¯¢ï¼Œä»…æŸ¥è¯¢å…¥å£ï¼›å¼€å¯ yisp || yw || flag å‚æ•°å xy å‚æ•°æ— æ•ˆ
 * 
 * å›¾æ ‡å‚æ•°
 * - [game]      å¢åŠ æ¸¸æˆèŠ‚ç‚¹æ ‡è¯†ï¼›
 * - [flag]      å¢åŠ å›½å®¶æˆ–åœ°åŒºçš„æ——å¸œæ ‡è¯†ï¼Œé»˜è®¤æ— æ­¤å‚æ•°ï¼›
 * - [bl]        ä¿ç•™å€ç‡æ ‡è¯†ï¼›
 * - [snone]     æ¸…ç†æŸåœ°åŒºå†…åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„åºå·ï¼›
 * 
 * åˆ†éš”ç¬¦å‚æ•°
 * - [fgf=]      è®¾ç½®å…¥å£å’Œè½åœ°ä¹‹é—´çš„åˆ†éš”ç¬¦ï¼Œé»˜è®¤ä¸ºç©ºæ ¼ï¼›
 * - [sn=]       è®¾ç½®å›½å®¶ä¸åºå·ä¹‹é—´çš„åˆ†éš”ç¬¦ï¼Œé»˜è®¤ä¸ºç©ºæ ¼ï¼›
 * - [name=]     ä¸ºèŠ‚ç‚¹æ·»åŠ æœºåœºåç§°å‰ç¼€ï¼›
 * 
 * é€šçŸ¥å‚æ•°
 * - [offtz]     å…³é—­è„šæœ¬é€šçŸ¥ï¼›
 * 
 * è§£æå‚æ•°
 * - [dnsjx]     å°†èŠ‚ç‚¹åŸŸåè§£æä¸ºIPï¼Œæ™®é€šç”¨æˆ·ä¸å»ºè®®ä½¿ç”¨ï¼›
 * 
 * é€»è¾‘å‚æ•°
 * - [bs=]       æ‰¹å¤„ç†èŠ‚ç‚¹æ•°å»ºè®®10ä¸ªå·¦å³ï¼Œå¦‚æœç»å¸¸è¯»ä¸åˆ°èŠ‚ç‚¹å»ºè®®å‡å°æ‰¹å¤„ç†ä¸ªæ•°ï¼›
 * 
 * ç¼“å­˜å‚æ•°
 * - [h=]        èŠ‚ç‚¹ç¼“å­˜æœ‰æ•ˆæœŸï¼Œå•ä½å°æ—¶ï¼Œæ—¶é—´å‚æ•°åªèƒ½äºŒé€‰ä¸€ï¼ŒLoonç”¨æˆ·ä¸éœ€å¡«å†™è¦æ­¤å‚æ•°ï¼Œè¯·è¿›å…¥Sub-Storeæ’ä»¶çš„é…ç½®ç•Œé¢è‡ªå®šä¹‰ç¼“å­˜æœ‰æ•ˆæœŸï¼›
 * - [min=]      èŠ‚ç‚¹ç¼“å­˜æœ‰æ•ˆæœŸï¼Œå•ä½åˆ†é’Ÿï¼Œæ—¶é—´å‚æ•°åªèƒ½äºŒé€‰ä¸€ï¼ŒLoonç”¨æˆ·ä¸éœ€å¡«å†™è¦æ­¤å‚æ•°ï¼Œè¯·è¿›å…¥Sub-Storeæ’ä»¶çš„é…ç½®ç•Œé¢è‡ªå®šä¹‰ç¼“å­˜æœ‰æ•ˆæœŸï¼›
 * 
 * è¶…æ—¶å‚æ•°
 * - [timeout=]  å½“æ— ä»»ä½•èŠ‚ç‚¹ç¼“å­˜æ—¶æµ‹è¯•èŠ‚ç‚¹HTTPå»¶æ—¶å…è®¸çš„æœ€å¤§è¶…æ—¶å‚æ•°ï¼Œè¶…å‡ºå…è®¸èŒƒå›´åˆ™åˆ¤å®šä¸ºæ— æ•ˆèŠ‚ç‚¹ï¼Œé»˜è®¤2000msï¼›
 * - [cd=]       å½“æœ‰ç¼“å­˜æ—¶ï¼Œä¼šå…ˆè¯»å–ç¼“å­˜ï¼Œç›´æ¥è¾“å‡ºç»“æœï¼›é»˜è®¤ [cd=]çš„å€¼ç­‰äº0ï¼Œå¾®ç›´æ¥è¯»å–ç¼“å­˜ï¼› 
å½“è®¾ä¸ºæ›´é«˜çš„å€¼: æ¯”å¦‚'460'åˆ™æ¯æ¬¡è¯»ç¼“å­˜éƒ½ä¼šå†æ¬¡å¤„ç†ä¹‹å‰åˆ¤å®šä¸ºè¶…æ—¶çš„èŠ‚ç‚¹,è¶…æ—¶ä¸º460ms
*
* å…¶ä»–å‚æ•°
* - [debug]     è°ƒè¯•æ—¥å¿—ï¼Œæ™®é€šç”¨æˆ·ä¸å»ºè®®ä½¿ç”¨ã€‚
* - å¼‚å¸¸ï¼šå¦‚é‡é—®é¢˜ï¼ŒLoonå¯ä»¥è¿›å…¥[é…ç½®]â†’[æŒä¹…åŒ–ç¼“å­˜]â†’[åˆ é™¤æŒ‡å®šæ•°æ®]â†’è¾“å…¥Key [sub-store-cached-script-resource]å¹¶åˆ é™¤ç¼“å­˜ã€‚ç´¯è®¡è¾“å‡ºèŠ‚ç‚¹ä¸º0ä¸ª3æ¬¡ä»¥ä¸Šå°†æ¸…ç†æ‰€æœ‰ç¼“å­˜
* - Surgeéœ€è¦è¿›å…¥[è„šæœ¬ç¼–è¾‘å™¨]â†’å·¦ä¸‹è§’[è®¾ç½®]â†’[$persistentStore]  [sub-store-cached-script-resource]åˆ é™¤ç¼“å­˜æ•°æ®ã€‚
*/

const SUB_STORE_SCHEMA = {
  title: "CNAME",
  description: "æ ¹æ®æ¥å£è¿”å›çš„çœŸå®ç»“æœï¼Œé‡æ–°å¯¹èŠ‚ç‚¹å‘½å/å»é‡ã€‚ å¦‚ï¼šå…¥å£/è½åœ°è¯¦ç»†åœ°åŒºä¿¡æ¯",
  scope: ["Surge", "Loon"],
  author: "@Key @å¥¶èŒ¶å§ @å°ä¸€ @å¯è‰",
  updateTime: "2023-11-11 18:26:00",
  version: "1.2.2",
  params: {
    flag: {
      datatype: "boolean",
      description: "å¢åŠ è½åœ°å›½å®¶æˆ–åœ°åŒºçš„æ——å¸œæ ‡è¯†ï¼Œé»˜è®¤æ— æ­¤å‚æ•°",
      defaultValue: false,
    },
    inflag:{
      datatype: "boolean",
      description: "å¢åŠ å…¥å£å›½å®¶æˆ–åœ°åŒºçš„æ——å¸œæ ‡è¯†ï¼Œé»˜è®¤æ— æ­¤å‚æ•°",
      defaultValue: false,
    },
    xy: {
      datatype: "boolean",
      description: "å…³é—­è½åœ°æŸ¥è¯¢ï¼Œä»…æŸ¥è¯¢å…¥å£ï¼›å¼€å¯ yisp || yw || flag å‚æ•°å xy å‚æ•°æ— æ•ˆ",
      defaultValue: false,
    },
    iisp: {
      datatype: "boolean",
      description: "å¢åŠ å…¥å£è¿è¥å•†æˆ–è€…ç›´è¿æ ‡è¯†",
      defaultValue: false,
    },
    city: {
      datatype: "boolean",
      description: "å¢åŠ å…¥å£åŸå¸‚æ–‡å­—æ ‡è¯†",
      defaultValue: false,
    },
    sheng: {
      datatype: "boolean",
      description: "å¢åŠ å…¥å£çœä»½æ–‡å­—æ ‡è¯†",
      defaultValue: false,
    },
    yuan: {
      datatype: "boolean",
      description:
        "ä¸ºå¢ƒå¤–å…¥å£æ·»åŠ çœŸå®çš„å…¥å£å±åœ°æ ‡è¯†ï¼Œå½“æœªé…ç½®æ­¤æ­¤å‚æ•°æ—¶ï¼Œåˆ™å°†å¢ƒå¤–å…¥å£ç»Ÿä¸€æ ‡è®°ä¸º[å¢ƒå¤–]ï¼Œé»˜è®¤æœªé…ç½®æ­¤å‚æ•°",
      defaultValue: false,
    },
    yisp: {
      datatype: "boolean",
      description: "æ˜¾ç¤ºè½åœ°è¯¦ç»†è¿è¥å•†åç§°",
      defaultValue: false,
    },
    yw: {
      datatype: "boolean",
      description:
        "è½åœ°å½’å±åœ°ä½¿ç”¨è‹±æ–‡ç¼©å†™æ ‡è¯†ï¼Œä¸å»ºè®®ä¸å…¶ä»–å…¥å£å‚æ•°é…åˆä½¿ç”¨ï¼Œå› ä¸ºå…¶ä»–å‚æ•°APIæ²¡æœ‰è¿”å›è‹±æ–‡",
      defaultValue: false,
    },
    game: {
      datatype: "boolean",
      description: "å¢åŠ æ¸¸æˆèŠ‚ç‚¹æ ‡è¯†",
      defaultValue: false,
    },
    bl: {
      datatype: "boolean",
      description: "ä¿ç•™å€ç‡æ ‡è¯†",
      defaultValue: false,
    },
    snone: {
      datatype: "boolean",
      description: "æ¸…ç†æŸåœ°åŒºå†…åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„åºå·",
      defaultValue: false,
    },
    offtz: {
      datatype: "boolean",
      description: "å…³é—­è„šæœ¬é€šçŸ¥",
      defaultValue: false,
    },
    dnsjx: {
      datatype: "boolean",
      description: "å°†èŠ‚ç‚¹åŸŸåè§£æä¸ºIP, æ™®é€šç”¨æˆ·ä¸å»ºè®®ä½¿ç”¨",
      defaultValue: false,
    },
    debug: {
      datatype: "boolean",
      description: "è°ƒè¯•æ—¥å¿—ï¼Œæ™®é€šç”¨æˆ·ä¸å»ºè®®ä½¿ç”¨",
      defaultValue: false,
    },
    fgf: {
      datatype: "string",
      description: "è®¾ç½®å…¥å£å’Œè½åœ°ä¹‹é—´çš„åˆ†éš”ç¬¦ï¼Œé»˜è®¤ä¸ºç©ºæ ¼",
      defaultValue: " ",
    },
    sn: {
      datatype: "string",
      description: "è®¾ç½®å›½å®¶ä¸åºå·ä¹‹é—´çš„åˆ†éš”ç¬¦ï¼Œé»˜è®¤ä¸ºç©ºæ ¼",
      defaultValue: " ",
    },
    name: {
      datatype: "string",
      description: "ä¸ºèŠ‚ç‚¹æ·»åŠ æœºåœºåç§°å‰ç¼€",
      defaultValue: "",
    },
    timeout: {
      datatype: "number",
      description:
        "å½“æ— ä»»ä½•èŠ‚ç‚¹ç¼“å­˜æ—¶æµ‹è¯•èŠ‚ç‚¹HTTPå»¶æ—¶å…è®¸çš„æœ€å¤§è¶…æ—¶å‚æ•°ï¼Œè¶…å‡ºå…è®¸èŒƒå›´åˆ™åˆ¤å®šä¸ºæ— æ•ˆèŠ‚ç‚¹ï¼Œé»˜è®¤2000ms",
      defaultValue: 2000,
    },
    cd: {
      datatype: "number",
      description:
        "å½“æœ‰ç¼“å­˜æ—¶ï¼Œä¼šå…ˆè¯»å–ç¼“å­˜ï¼Œç›´æ¥è¾“å‡ºç»“æœï¼›é»˜è®¤[cd=]çš„å€¼ç­‰äº0ï¼Œå¾®ç›´æ¥è¯»å–ç¼“å­˜ï¼› å½“è®¾ä¸ºæ›´é«˜çš„å€¼: æ¯”å¦‚'460'åˆ™æ¯æ¬¡è¯»ç¼“å­˜éƒ½ä¼šå†æ¬¡å¤„ç†ä¹‹å‰åˆ¤å®šä¸ºè¶…æ—¶çš„èŠ‚ç‚¹,è¶…æ—¶ä¸º460ms",
      defaultValue: 0,
    },
    bs: {
      datatype: "number",
      description:
        "æ‰¹å¤„ç†èŠ‚ç‚¹æ•°å»ºè®®10ä¸ªå·¦å³ï¼Œå¦‚æœç»å¸¸è¯»ä¸åˆ°èŠ‚ç‚¹å»ºè®®å‡å°æ‰¹å¤„ç†ä¸ªæ•°",
      defaultValue: 10,
    },
    h: {
      datatype: "number",
      description:
        "èŠ‚ç‚¹ç¼“å­˜æœ‰æ•ˆæœŸï¼Œå•ä½å°æ—¶ï¼Œæ—¶é—´å‚æ•°åªèƒ½äºŒé€‰ä¸€ï¼ŒLoonç”¨æˆ·ä¸éœ€å¡«å†™è¦æ­¤å‚æ•°ï¼Œè¯·è¿›å…¥Sub-Storeæ’ä»¶çš„é…ç½®ç•Œé¢è‡ªå®šä¹‰ç¼“å­˜æœ‰æ•ˆæœŸ",
      defaultValue: "",
    },
    min: {
      datatype: "number",
      description:
        "èŠ‚ç‚¹ç¼“å­˜æœ‰æ•ˆæœŸï¼Œå•ä½åˆ†é’Ÿï¼Œæ—¶é—´å‚æ•°åªèƒ½äºŒé€‰ä¸€ï¼ŒLoonç”¨æˆ·ä¸éœ€å¡«å†™è¦æ­¤å‚æ•°ï¼Œè¯·è¿›å…¥Sub-Storeæ’ä»¶çš„é…ç½®ç•Œé¢è‡ªå®šä¹‰ç¼“å­˜æœ‰æ•ˆæœŸ",
      defaultValue: "",
    },
  },
};


const $ = $substore;
const iar = $arguments;
let FGF = iar.fgf == undefined ? " " : decodeURI(iar.fgf),FGFS = FGF,debug = iar.debug;
const { yw, bl, iisp, xy,  yisp, yun, city, flag, inflag, game, yuan, sheng, offtz, snone: numone} = iar;
const h = iar.h ? decodeURI(iar.h) : "",min = iar.min ? decodeURI(iar.min) : "",firstN = iar.name ? decodeURI(iar.name) : "";
const XHFGF = iar.sn == undefined ? " " : decodeURI(iar.sn),{ isLoon: isLoon, isSurge: isSurge } = $substore.env, dns = iar.dnsjx,target = isLoon ? "Loon" : isSurge ? "Surge" : undefined,keypr= "peedtest";
let cd = iar.cd ? iar.cd : 0, timeout = iar.timeout ? iar.timeout : 2000, writet = "", innum = 1728e5, loontrue = false, onen = false, Sue = false, rawtime = 1500;
const keyp = "3.s",EXPIRATION_KEY = "#sub-store-csr-expiration-time";
if (min !== "") {
  Sue = true;
  innum = parseInt(min, 10) * 6e4;
  writet = $.write(JSON.stringify(innum), EXPIRATION_KEY);
} else if (h !== "") {
  Sue = true;
  innum = parseInt(h, 10) * 36e5;
  writet = $.write(JSON.stringify(innum), EXPIRATION_KEY);
} else {
  writet = $.write(JSON.stringify(innum), EXPIRATION_KEY);
}
let TIMEDKEY = $.read(EXPIRATION_KEY),inapi=0;
async function operator(e = [], targetPlatform, env) {
  let tzname = "", subcoll = "", x = false, xys = false;
  if (env?.source?.[e?.[0]?.subName]) x = true;
  if (env?.source?._collection?.name) xys = true;
  if (x && xys) {
    tzname =
      env.source._collection.name + ": [" + env.source._collection.subscriptions + "]";
    subcoll = "ç»„åˆè®¢é˜…å†…å•æ¡è®¢é˜…åŠ äº†è„šæœ¬, è¾“å‡ºç»„åˆè®¢é˜…";
  } else if (x) {
    tzname = env.source[e[0].subName].name;
    subcoll = "å•æ¡è®¢é˜…è„šæœ¬";
  } else {
    tzname = env.source._collection.name;
    subcoll = "ç»„åˆè®¢é˜…è„šæœ¬";
  }
  const startTime = new Date();
  const support = isLoon || isSurge;
  if (!xy) {
    if (!support) {
      $.notify("No Loon or Surge")
      $.error(`No Loon or Surge`);
        return e;
      }
  }
  function klog(...arg) {
    console.log('[CNAME] ' +subcoll+ tzname +" : "+ arg);
  }
  if (e.length < 1) {$.notify(subcoll +tzname,"è®¢é˜…æ— èŠ‚ç‚¹","",{url: "https://raw.githubusercontent.com/sub-store-org/Sub-Store/master/config/Surge-ability.sgmodule",});return e;}
  if (typeof scriptResourceCache === "undefined")return e;
  let bs = iar.bs ? iar.bs : 9;
  const ein = e.length;
  const eins = ein/2;
  klog(`å¼€å§‹å¤„ç†èŠ‚ç‚¹: ${ein} ä¸ª`);
  klog(`æ‰¹å¤„ç†èŠ‚ç‚¹æ•°: ${bs} ä¸ª`);
  klog(`è®¾å®šapiè¶…æ—¶: ${zhTime(timeout)}`);
  klog(`æœ‰ç¼“apiè¶…æ—¶: ${zhTime(cd)}`);
  // e = e.filter((item) => !nlc.test(item.name));
  let o = 0,Pushtd = "",intimed = "",stops = false,rere=false,iflag="",cachen = 0;
  while (o < e.length && !stops) {
    const batchs = e.slice(o, o + 1);
    await Promise.all(
      batchs.map(async (pk) => {
        try {
          const inss = new Map();
          const id = getid(pk);
          if (inss.has(id)) {
            return inss.get(id);
          }
          const cacheds = scriptResourceCache.get(id);
          if (cacheds) cachen++;
          if (cachen > eins) {
            if (!onen) {
              klog(`æ£€æŸ¥ç¼“å­˜æ•°é‡: ${cachen}/${ein} ä¸ª`);
              rawtime = timeout;
              timeout = cd;
              onen = true;
              stops = true;
            }
            const readt = scriptResourceCache.gettime(id);
            let nt = new Date().getTime();
            let timedPush = "";
            if (isLoon) {
              let loontd = "";
              const loonkkk={"1åˆ†é’Ÿ":6e4,"5åˆ†é’Ÿ":3e5,"10åˆ†é’Ÿ":6e5,"30åˆ†é’Ÿ":18e5,"1å°æ—¶":36e5,"2å°æ—¶":72e5,"3å°æ—¶":108e5,"6å°æ—¶":216e5,"12å°æ—¶":432e5,"24å°æ—¶":864e5,"48å°æ—¶":1728e5,"72å°æ—¶":2592e5,å‚æ•°ä¼ å…¥:"innums"};
              intimed = $.read("#èŠ‚ç‚¹ç¼“å­˜æœ‰æ•ˆæœŸ");
              loontd = loonkkk[intimed] || 1728e5;
              if (loontd == "innums") {
                loontd = innum;
              }
              timedPush = zhTime(
                parseInt(readt, 10) - nt + parseInt(loontd, 10)
              );
            } else if (target === "Surge" && Sue) {
              timedPush = zhTime(
                parseInt(readt, 10) - nt + parseInt(innum, 10)
              );
            } else {
              timedPush = zhTime(
                parseInt(readt, 10) - nt + parseInt(TIMEDKEY, 10)
              );
            }
            Pushtd = `, ${timedPush}åè¿‡æœŸ \n`;
          }
        } catch (err) {delog(err.message)}
      })
    );
    o += 1;
  }
  if (!onen && !offtz) $.notify(subcoll+tzname, `å¼€å§‹å¤„ç†èŠ‚ç‚¹: ${ein} ä¸ª æ‰¹å¤„ç†æ•°é‡: ${bs} ä¸ª`, "è¯·ç­‰å¾…å¤„ç†å®Œæ¯•åå†æ¬¡ç‚¹å‡»é¢„è§ˆ");

  let retryi = 0,breaki=false, isone = 0;
  do {
    let i = 0,newnode = [];isone++;
    while (i < e.length) {
      const batch = e.slice(i, i + bs);
      await Promise.all(
        batch.map(async (pk) => {
            try {
              let keyover = [], Yserver = pk.server,luodi = "",inQcip = "",nxx = "",adflag = "",OGame="",Oisp="",Oispflag="",Osh="", Oct="",zhi = "",yuanisp ="",isCN = false,v4 = false, v6 = false, isNoAli = false;
              let inServer = await AliD(Yserver);
              delog(inServer)
              switch (inServer) {
                case "keyn":
                  isNoAli = true;
                  inServer = Yserver;
                  break;
                default:
                  pk.keyrk = inServer;
                  if (!isNoAli) {
                    if (/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(inServer)) {
                      v4 = true;
                    } else if (/^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/.test(inServer)) {
                      v6 = true;
                    }
                  }
                  break;
              }
              
              let btip = true,outu="",outips="";
              if (!xy || yisp || yw || flag) {
                if (!support) {
                  $.notify("No Loon or Surge")
                  $.error(`No Loon or Surge, å¼€å¯ yisp || yw || flag å‚æ•°å xy å‚æ•°æ— æ•ˆ`);
                    return e;
                  }
                  
                const outip = await OUTIA(pk);
                let {country:outUsq, countryCode:outUs, city:outCity, query:outQuery, isp:outisp} = outip;//è½åœ°
                if (yisp) {
                    yuanisp = FGFS+outisp
                };
                debug && (pk.keyoutld = outip);
                delog("è½åœ°ä¿¡æ¯ " + JSON.stringify(outip))
                outu = outUs;
                outips = outQuery;
                luodi = (outUsq === "ä¸­å›½") ? outCity : (yw ? outUs : outUsq);
                btip = outQuery !== inServer
              };
              
              if (btip || xy) {
                if (!isNoAli || v4) {
                  const spkey = await SPEC(inServer);
                  let {country:inSpCn,regionName:inSpSheng,city:inSpCity,isp:inSpIsp,ip:inSpIp,countryCode:inCode} = spkey;
                  inflag && (iflag = getflag(inCode));
                  debug && (pk.keyinsp = spkey);
                  isCN = inSpCn === "ä¸­å›½";
                  inQcip = inServer;
                  const keycm = {ç”µä¿¡:"ğŸ…³", è”é€š:"ğŸ…»", ç§»åŠ¨: "ğŸ†ˆ",å¹¿ç”µ:"ğŸ…¶"};
                  if (isCN){
                      debug && (pk.keyinsp = spkey)
                      delog("å›½å†…å…¥å£ " + JSON.stringify(spkey));
                      if(iisp && flag){
                          inSpIsp=inSpIsp.replace(/ä¸­å›½/g, "")
                          flag && (Oispflag = keycm.hasOwnProperty(inSpIsp) ? keycm[inSpIsp] : "ğŸ…²");
                      } else if(iisp){
                          Oisp = /ç”µä¿¡|è”é€š|ç§»åŠ¨|å¹¿ç”µ/.test(inSpIsp) ? inSpIsp.replace(/ä¸­å›½/g, "") : "ä¼ä¸š";
                      }
                      (inSpSheng === inSpCity) && (inSpCity = "");

                      if (sheng && city){
                        Osh = inSpSheng;Oct = inSpCity
                      } else if (sheng){
                        Osh = inSpSheng;
                      } else if (city){
                        Oct = inSpCity ? inSpCity : inSpSheng;
                      }

                  }    
                }    
                if (isNoAli || v6 || !isCN) {
                      const inip = await INIA(Yserver);
                      let {country: inUsq, city: inCity, query: inQuery, regionName: inIpSh, countryCode:inaCode} = inip;
                      inflag && (iflag = getflag(inaCode));
                      debug && (pk.keyinipapi = inip);
                      delog("ipapiå…¥å£ " + JSON.stringify(inip));
                      inQcip = inQuery; //å»é‡ip
                      if (inUsq === "ä¸­å›½") {
                          // inCity === inUs ? (incity=inCity) 
                          (/[a-zA-Z]/.test(inCity)) && (inCity = inIpSh);
                          (inCity === inIpSh) && (inIpSh="");
                          if (sheng && city){
                            Osh = inIpSh;Oct = inCity;
                          } else if (sheng){
                            Osh = inIpSh;
                          } else if (city){
                            Oct = inCity ? inCity : inIpSh;
                          }
                          // è¿è¥å•† æœªçŸ¥
                          flag && (Oispflag = "ğŸ…²");

                      } else {
                          if(inQuery === outips){
                              flag && (Oispflag = "ğŸ†‰");
                              (sheng || city || iisp) && (zhi  = "ç›´è¿");
                          } else if (yuan){
                              flag && (Oispflag = "ğŸ…²");
                              (sheng || city || iisp) && (zhi  = inUsq);
                          } else {
                              flag && (Oispflag = "ğŸ†‡");
                              (sheng || city || iisp) && (zhi  = "å¢ƒå¤–");
                          }
                      }
                }
              } else {
                flag && (Oispflag = "ğŸ†‰");
                (sheng || city || iisp) && (zhi  = "ç›´è¿");
              }
              flag && (adflag = getflag(outu));
              game && (OGame = /game|æ¸¸æˆ/i.test(pk.name) ? (flag ? "ğŸ®" : FGF+"Game") : OGame);
              if (bl){
                const match = pk.name.match(/((å€ç‡|X|x|Ã—)\D?((\d\.)?\d+)\D?)|((\d\.)?\d+)(å€|X|x|Ã—)/);
                if (match) {
                const matchVa = match[0].match(/(\d[\d.]*)\D?/)[0];
                    if (matchVa !== "1") {
                        nxx = XHFGF + matchVa + "X";
                    }
                }
              }
              (!iisp && !city && !sheng && !xy && !inflag) && (Oispflag = "",FGF ="");
              keyover = keyover.concat(
                  firstN, Oispflag,Osh,Oct,Oisp,zhi,FGF,adflag,luodi,OGame,nxx,yuanisp
                  ).filter(ki => ki !== "");
                  // delog(keyover)
              let overName = keyover.join("");
              xy && (overName = iflag +overName +FGF+ pk.name);
              // delog(overName)
              newnode.push(outips);
              dns && (pk.server = inQcip);
              pk.name = overName;
              inflag && (pk.name = iflag + overName);
              pk.qc = inQcip + outips;
            } catch (err) {
              if (inapi >= 1) {
                retryi++;
                breaki = true;
              }
              delog(err.message)
            };
        })
      );
      i += bs;
      klog(`å¤„ç†è¿›åº¦${i}/${ein}`)
      if (!onen){
        if(!offtz && (ein > (i*2)){
            if (i >= (e.length / 3) && i < (e.length * 2 / 3) && ein>i) {
                $.notify(subcoll+tzname, `å¤„ç†è¿›åº¦${i}/${ein}`, "è€å¿ƒç­‰å¾…, è¯·å‹¿é‡å¤ç‚¹å‡»é¢„è§ˆ...");
            }
        }
        await sleep(GRa());
      }
    }
    !xy && (e = removels(e));
    var eout = e.length;
    if (eout > 3 && isSurge){
      const allsame = newnode.every((value, index, arr) => value === arr[0]);
      if(allsame){
          klog(`æœªä½¿ç”¨å¸¦æŒ‡å®šèŠ‚ç‚¹åŠŸèƒ½çš„ SubStore, æˆ–æ‰€æœ‰èŠ‚ç‚¹è½åœ°IPç›¸åŒ`);
          $.notify('CNAMEï¼šç‚¹å‡»ä»¥å®‰è£…å¯¹åº”ç‰ˆæœ¬','æœªä½¿ç”¨å¸¦æŒ‡å®šèŠ‚ç‚¹åŠŸèƒ½çš„ SubStoreï¼Œæˆ–æ‰€æœ‰èŠ‚ç‚¹è½åœ°IPç›¸åŒ','',{url: "https://raw.githubusercontent.com/sub-store-org/Sub-Store/master/config/Surge-ability.sgmodule",})
          return e;
      }
    }
    if (inapi >= 1) {
      retryi++;
      timeout = rawtime;
      onen = false;
      spMap.clear();alMap.clear();iaMap.clear();oaMap.clear();
      klog(`é‡è¯•ä¸­...`);
    } else {
      retryi = 2;
    }
  } while(retryi < 2);
    
  !xy && (e = removeqc(e));
  e = jxh(e);
  // if (firstN !== "") {e.forEach((pk) => {pk.name = firstN + " " + pk.name;});}
  numone && (e = onee(e));
  const endTime = new Date();
  const timeDiff = endTime.getTime() - startTime.getTime();
  if (dns) {
    klog(`dnsè§£æåå…±: ${eout} ä¸ª`);
  }
  apiRead > 0 ? klog(`è¯»å–apiç¼“å­˜: ${apiRead} ä¸ª`) : null;
  apiw > 0 ? klog(`å†™å…¥apiç¼“å­˜: ${apiw} ä¸ª`) : null;
  klog(`å¤„ç†å®Œåå‰©ä½™: ${eout} ä¸ª`);
  // const Nullv ='#SubStoreNullvalue';
  // if (eout === 0 && ein !== 0){
  //   let Nullvi = parseInt($.read(Nullv), 10);
  //   if (isNaN(Nullvi)) {
  //     klog(`é”™è¯¯1æ¬¡, 3æ¬¡åå°†æ¸…ç†æ‰€æœ‰èŠ‚ç‚¹ç¼“å­˜`);
  //     $.write("0", Nullv);
  //   } else {
  //     Nullvi += 1;
  //     klog(`é”™è¯¯${Nullvi}æ¬¡, 3æ¬¡åå°†æ¸…ç†æ‰€æœ‰èŠ‚ç‚¹ç¼“å­˜`);
  //     $.write(Nullvi.toString(), Nullv);
  //   }
  //   if (Nullvi > 3) {
  //     $.write({}, "#sub-store-cached-script-resource");
  //     klog(`é”™è¯¯${Nullvi}æ¬¡, å·²æ¸…ç†æ‰€æœ‰èŠ‚ç‚¹ç¼“å­˜`);
  //     Nullvi = 0;
  //     $.write(Nullvi.toString(), Nullv);
  //   }
  // }
  if (isLoon) {
    klog("ç¼“å­˜è¿‡æœŸæ—¶é—´: " + intimed + ", è¿˜å‰©" + Pushtd.replace(/,|\n/g, ""));
  } else {
    klog("ç¼“å­˜è¿‡æœŸæ—¶é—´: " +zhTime(TIMEDKEY) +", è¿˜å‰©" +Pushtd.replace(/,|\n/g, ""));
  }
  klog(`æ­¤æ–¹æ³•æ€»ç”¨æ—¶: ${zhTime(timeDiff)}\n----For New CNAME----\n\n\n\n\n`);
  const readklog = apiRead ? `è¯»å–ç¼“å­˜:${apiRead} ` : "";
  const writeklog = apiw ? `å†™å…¥ç¼“å­˜:${apiw}, ` : "";
  const Push = (eout === ein && eout === 0) ? "" : (eout === ein ? "å…¨éƒ¨é€šè¿‡æµ‹è¯•, " : "å»é™¤æ— æ•ˆèŠ‚ç‚¹åæœ‰" + eout + "ä¸ª, ");
  if (!offtz) {$.notify(
      `${subcoll}${tzname} å…±${ein}ä¸ªèŠ‚ç‚¹`,
      "",
      `${writeklog}${readklog}${Pushtd}${Push}ç”¨æ—¶:${zhTime(timeDiff)}`
      );}
  return e;
}

// FNV-1a å‡½æ•° - æ›¿ä»£ MD5ï¼Œæ€§èƒ½æå‡çº¦4å€
function FNV1a(str) {
    let hash = 0x811c9dc5;
    const prime = 0x01000193;
    for (let i = 0; i < str.length; i++) {
        hash ^= str.charCodeAt(i);
        hash = Math.imul(hash, prime);
    }
    return (hash >>> 0).toString(16).padStart(8, '0');
}

function getflag(e) { const t = e .toUpperCase() .split("") .map((e) => 127397 + e.charCodeAt()); return String.fromCodePoint(...t).replace(/ğŸ‡¹ğŸ‡¼/g, "ğŸ‡¨ğŸ‡³"); } function sleep(e) { return new Promise((t) => setTimeout(t, e)); } let apiRead = 0, apiw = 0; 
const oaMap = new Map(); async function OUTIA(e) { const t = getid(e); if (oaMap.has(t)) return oaMap.get(t); const cached = scriptResourceCache.get(t);if (cached) { apiRead++; return cached; } else {inapi++;};const maxRE = 2; const url = `http://ip-api.com/json?lang=zh-CN&fields=status,message,country,countryCode,city,query,isp`; const getHttp = async (reTry) => { try { let r = ProxyUtils.produce([e], target); const response = await Promise.race([ $.http.get({ url: url, node: r, "policy-descriptor": r }), new Promise((_, reject) => setTimeout(() => reject(new Error("timeout-OUTIA")), timeout) ), ]); const data = JSON.parse(response.body); if (data.status === "success") { scriptResourceCache.set(t, data); return data; } else { throw new Error(resdata.message); } } catch (error) { if (reTry < maxRE) { await sleep(GRa()); delog(e.name + "-> [outipApiè¶…æ—¶æŸ¥è¯¢æ¬¡æ•°] " + reTry); return getHttp(reTry + 1); } else { throw error; } } }; const resGet = new Promise((resolve, reject) => { if (cd < 1 && onen) return resGet; getHttp(1) .then((data) => { apiw++; resolve(data); }) .catch(reject); }); oaMap.set(t, resGet); return resGet; };
const alMap = new Map(); async function AliD(e) { const ti = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$|^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/.test( e ); if (ti) return e; const t = getaliid(e); if (alMap.has(t)) return alMap.get(t); const cached = scriptResourceCache.get(t); if (cached) { apiRead++; return cached;} else {inapi++;};const maxRE = 2; let alip = Math.random() < 0.5 ? '223.5.5.5' : '223.6.6.6';const url = `https://${alip}/resolve?name=${e}&type=A&short=1`; const getHttp = async (reTry) => { try { const response = await Promise.race([ $.http.get({ url: url }), new Promise((_, reject) => setTimeout(() => reject(new Error("timeout-AliD")), timeout) ), ]); const resdata = JSON.parse(response.body); if (resdata.length > 0) { scriptResourceCache.set(t, resdata[0]); return resdata[0]; } else { return "keyn"; } } catch (error) { if (reTry < maxRE) { await sleep(GRa()); delog(e + " [->Aliè¶…æ—¶æŸ¥è¯¢æ¬¡æ•°] " + reTry); return getHttp(reTry + 1); } else { throw error; } } }; const resGet = new Promise((resolve, reject) => { if (cd < 1 && onen) { return resGet; } else { getHttp(1) .then((data) => { resolve(data); }) .catch(reject); } }); alMap.set(t, resGet); return resGet; };function getaliid(e){let t="al";return FNV1a(`${t}-${e}`)};function getspcn(e){let t="sc";return FNV1a(`${t}-${e}`)};
const spMap = new Map(); async function SPEC(e) { const n = getspcn(e); if (spMap.has(n)) return spMap.get(n);const cached = scriptResourceCache.get(n); if (cached) {apiRead++;return cached;} else {inapi++;}; const maxRE = 2; const url = `https://api-v${keyp}${keypr}.cn/ip?ip=${e}`; const getHttp = async (reTry) => { try { const response = await Promise.race([ $.http.get({ url: url }), new Promise((_, reject) => setTimeout(() => reject(new Error("timeout-SPEC")), timeout) ), ]); const resdata = JSON.parse(response.body); delog(resdata); if (resdata.data) { const { country: e, province: o, city: r, isp: i, ip: c, countryCode: k, } = resdata.data; const a = { country: e, regionName: o, city: r, isp: i, ip: c, countryCode: k, }; delog("å†™å…¥"); scriptResourceCache.set(n, a); return a; } else { throw new Error(resdata.message); } } catch (error) { if (reTry < maxRE) { await sleep(GRa()); delog(e + "-> [SPè¶…æ—¶æŸ¥è¯¢æ¬¡æ•°] " + reTry); return getHttp(reTry + 1); } else { throw error; } } }; const resGet = new Promise((resolve, reject) => {if (cd < 1 && onen) return resGet; getHttp(1) .then((data) => { resolve(data); }) .catch(reject); }); spMap.set(n, resGet); return resGet; };
const iaMap = new Map(); async function INIA(e) { const t = getinid(e); if (iaMap.has(t)) return iaMap.get(t); const cached = scriptResourceCache.get(t); if (cached) {apiRead++;return cached;} else {inapi++;}; const maxRE = 2; const url = `http://ip-api.com/json/${e}?lang=zh-CN&fields=status,message,country,city,query,regionName,countryCode`; const getHttp = async (reTry) => { try { delog(url); const response = await Promise.race([ $.http.get({ url: url }), new Promise((_, reject) => setTimeout(() => reject(new Error("timeout-INIA")), timeout) ), ]); const data = JSON.parse(response.body); if (data.status === "success") { scriptResourceCache.set(t, data); return data; } else { throw new Error(resdata.message); } } catch (error) { if (reTry < maxRE) { await sleep(GRa()); delog(e + "-> [inipApiè¶…æ—¶æŸ¥è¯¢æ¬¡æ•°] " + reTry); return getHttp(reTry + 1); } else { throw error; } } }; const resGet = new Promise((resolve, reject) => { if (cd < 1 && onen) return resGet; getHttp(1) .then((data) => { resolve(data); }) .catch(reject); }); iaMap.set(t, resGet); return resGet; } function GRa() { return Math.floor(Math.random() * (500 - 50 + 1) + 50); };
function delog(...arg) { if (debug) { console.log("[CNAME] :" + arg); } } function removels(e) { const t = new Set(); const n = []; for (const s of e) { if (s.qc && !t.has(s.qc)) { t.add(s.qc); n.push(s); } } return n; } function removeqc(e) { const t = new Set(); const n = []; for (const s of e) { if (!t.has(s.qc)) { t.add(s.qc); const e = { ...s }; delete e.qc; n.push(e); } } return n; } function jxh(e) { const t = e.reduce((e, t) => { const n = e.find((e) => e.name === t.name); if (n) { n.count++; n.items.push({ ...t, name: `${t.name}${XHFGF}${n.count.toString().padStart(2, "0")}`, }); } else { e.push({ name: t.name, count: 1, items: [{ ...t, name: `${t.name}${XHFGF}01` }], }); } return e; }, []); const n = t.flatMap((e) => e.items); e.splice(0, e.length, ...n); return e; } 
function onee(e) { const t = e.reduce((e, t) => { const n = t.name.replace(/[^A-Za-z0-9\u00C0-\u017F\u4E00-\u9FFF]+\d+$/, ""); if (!e[n]) { e[n] = []; } e[n].push(t); return e; }, {}); for (const e in t) { if (t[e].length === 1 && t[e][0].name.endsWith("01")) { t[e][0].name= t[e][0].name.replace(/[^.]01/, "") } } return e; }
function zhTime(e) { e = e.toString().replace(/-/g, ""); if (e < 1e3) { return `${Math.round(e)}æ¯«ç§’`; } else if (e < 6e4) { return `${Math.round(e / 1e3)}ç§’`; } else if (e < 36e5) { return `${Math.round(e / 6e4)}åˆ†é’Ÿ`; } else if (e >= 36e5) { return `${Math.round(e / 36e5)}å°æ—¶`; } }
function getid(e){let t="ld";return FNV1a(`${t}-${e.server}-${e.port}`)}function getinid(e){let t="ia";return FNV1a(`${t}-${e}`)};
