/**
 * @Sub-Store-Page
 * DENAME æ¥å£æŸ¥è¯¢å»é‡/é‡å‘½å 2026-01-22 01:05:00
 * - å…¥å£æŸ¥è¯¢[å›½å†…spapi è¯†åˆ«åˆ°å›½å¤–ä¸ºip-api] è½åœ°æŸ¥è¯¢[ip-api]
 * - æ ¹æ®æ¥å£è¿”å›çš„çœŸå®ç»“æœï¼Œé‡æ–°å¯¹èŠ‚ç‚¹å‘½åã€‚
 * - æ·»åŠ å…¥å£åŸå¸‚ã€è½åœ°å›½å®¶æˆ–åœ°åŒºã€å›½å†…è¿è¥å•†ä¿¡æ¯ï¼Œå¹¶å¯¹è¿™äº›æ•°æ®åšæŒä¹…åŒ–ç¼“å­˜ï¼ˆ48å°æ—¶æœ‰æ•ˆæœŸï¼‰ï¼Œå‡å°‘APIè¯·æ±‚æ¬¡æ•°ï¼Œæé«˜è¿è¡Œæ•ˆç‡ã€‚
 * - ä»…å…¼å®¹ Surge, Loon å®¢æˆ·ç«¯ã€‚
 * - Surge éœ€è¦å›ºå®šå¸¦ ability å‚æ•°ç‰ˆæœ¬ã€‚
 * ç‰¹åˆ«è¯´æ˜ï¼š
 * - ç¬¦å·ï¼šğŸ…³ç”µä¿¡ ğŸ…»è”é€š ğŸ†ˆç§»åŠ¨ ğŸ…¶å¹¿ç”µ ğŸ…²å…¬å¸ ğŸ†‰ç›´è¿ ğŸ®æ¸¸æˆ
 * - é¦–æ¬¡è¿è¡Œæˆ–è€…åœ¨æ²¡æœ‰ç¼“å­˜çš„æƒ…å†µä¸‹ä¼šé€šçŸ¥è¿›åº¦
 * - æ— å‚æ•°æ—¶çš„èŠ‚ç‚¹å‘½åæ ¼å¼: "ç¾å›½ 01"
 * - 1. å®˜æ–¹é»˜è®¤ç‰ˆ(ç›®å‰ä¸å¸¦ ability å‚æ•°, ä¸ä¿è¯ä»¥åä¸ä¼šæ”¹åŠ¨): ã€‹https://raw.githubusercontent.com/sub-store-org/Sub-Store/master/config/Surge.sgmodule
 *
 * - 2. å›ºå®šå¸¦ ability å‚æ•°ç‰ˆæœ¬,å¯èƒ½ä¼šçˆ†å†…å­˜, å¦‚æœéœ€è¦ä½¿ç”¨æŒ‡å®šèŠ‚ç‚¹åŠŸèƒ½ ä¾‹å¦‚ [åŠ å›½æ——è„šæœ¬æˆ–è€…DENAMEè„šæœ¬] è¯·ä½¿ç”¨æ­¤å¸¦ ability å‚æ•°ç‰ˆæœ¬: https://raw.githubusercontent.com/sub-store-org/Sub-Store/master/config/Surge-ability.sgmodule
 *
 * - 3. å›ºå®šä¸å¸¦ ability å‚æ•°ç‰ˆæœ¬ï¼šhttps://raw.githubusercontent.com/sub-store-org/Sub-Store/master/config/Surge-Noability.sgmodule
 *
 * - å‚æ•°å¿…é¡»ä»¥"#"å¼€å¤´ï¼Œå¤šä¸ªå‚æ•°ä½¿ç”¨"&"è¿æ¥ï¼Œä¾‹å¦‚ https://github.com/Keywos/rule/raw/main/Dename.js#city&iisp&name=Name
 * - ä»¥ä¸‹æ˜¯æ­¤è„šæœ¬æ”¯æŒçš„å‚æ•°ï¼Œå¿…é¡»ä»¥"#"å¼€å¤´ï¼Œå¤šä¸ªå‚æ•°ä½¿ç”¨"&"è¿æ¥ï¼Œéœ€è¦ä¼ å…¥å‚æ•°çš„è¯ç”¨ "=" ä¾‹å¦‚ "name=ä¸€å…ƒ" å‚è€ƒä¸Šè¿°åœ°å€ä¸ºä¾‹ä½¿ç”¨å‚æ•°ã€‚
 * - æ— å‚æ•°æ—¶çš„èŠ‚ç‚¹å‘½åæ ¼å¼: "ç¾å›½ 01"ï¼Œå¦‚æœ [å…¥å£IPæˆ–å›½å®¶]æˆ– [è½åœ°IPæˆ–å›½å®¶]ä¸€æ ·åˆ™ä¸º "ç›´è¿ å¾·å›½ 01" 
 * - é¦–æ¬¡è¿è¡Œæˆ–è€…åœ¨æ²¡æœ‰ç¼“å­˜çš„æƒ…å†µä¸‹ä¼šé€šçŸ¥è¿›åº¦
 * 
 * 
 * å…¥å£å‚æ•°
 * - [iisp]      å¢åŠ å…¥å£è¿è¥å•†æˆ–è€…ç›´è¿æ ‡è¯†ï¼›
 * - [city]      å¢åŠ å…¥å£åŸå¸‚æ–‡å­—æ ‡è¯†ï¼›
 * - [sheng]     å¢åŠ å…¥å£çœä»½æ–‡å­—æ ‡è¯†ï¼›
 * - [yuan]      ä¸ºå¢ƒå¤–å…¥å£æ·»åŠ çœŸå®çš„å…¥å£å±åœ°æ ‡è¯†ï¼Œå½“æœªé…ç½®æ­¤æ­¤å‚æ•°æ—¶ï¼Œåˆ™å°†å¢ƒå¤–å…¥å£ç»Ÿä¸€æ ‡è®°ä¸º [å¢ƒå¤–]ï¼Œé»˜è®¤æœªé…ç½®æ­¤å‚æ•°ï¼›
 * - [inflag]    å¢åŠ å…¥å£å›½æ——
 * 
 * è½åœ°å‚æ•°
 * - [yisp]      æ˜¾ç¤ºè½åœ°è¯¦ç»†è¿è¥å•†åç§°ï¼›
 * - [yw]        è½åœ°å½’å±åœ°ä½¿ç”¨è‹±æ–‡ç¼©å†™æ ‡è¯†ï¼Œä¸å»ºè®®ä¸å…¶ä»–å…¥å£å‚æ•°é…åˆä½¿ç”¨ï¼Œå› ä¸ºå…¶ä»–å‚æ•°APIæ²¡æœ‰è¿”å›è‹±æ–‡ï¼›
 * - [xy]        æ­¤å‚æ•°å…³é—­è½åœ°æŸ¥è¯¢ï¼Œä»…æŸ¥è¯¢å…¥å£ï¼›å¼€å¯ yisp || yw || flag å‚æ•°å xy å‚æ•°æ— æ•ˆ
 * 
 * å›¾æ ‡å‚æ•°
 * - [game]      å¢åŠ æ¸¸æˆèŠ‚ç‚¹æ ‡è¯†ï¼›
 * - [flag]      å¢åŠ å›½å®¶æˆ–åœ°åŒºçš„æ——å¸œæ ‡è¯†ï¼Œé»˜è®¤æ— æ­¤å‚æ•°ï¼›
 * - [bl]        ä¿ç•™å€ç‡æ ‡è¯†ï¼›
 * - [snone]     æ¸…ç†æŸåœ°åŒºå†…åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„åºå·ï¼›
 * 
 * åˆ†éš”ç¬¦å‚æ•°
 * - [fgf=]      è®¾ç½®å…¥å£å’Œè½åœ°ä¹‹é—´çš„åˆ†éš”ç¬¦ï¼Œé»˜è®¤ä¸ºç©ºæ ¼ï¼›
 * - [sn=]       è®¾ç½®å›½å®¶ä¸åºå·ä¹‹é—´çš„åˆ†éš”ç¬¦ï¼Œé»˜è®¤ä¸ºç©ºæ ¼ï¼›
 * - [name=]     ä¸ºèŠ‚ç‚¹æ·»åŠ æœºåœºåç§°å‰ç¼€ï¼›
 * 
 * é€šçŸ¥å‚æ•°
 * - [offtz]     å…³é—­è„šæœ¬é€šçŸ¥ï¼›
 * 
 * è§£æå‚æ•°
 * - [dnsjx]     å°†èŠ‚ç‚¹åŸŸåè§£æä¸ºIPï¼Œæ™®é€šç”¨æˆ·ä¸å»ºè®®ä½¿ç”¨ï¼›
 * 
 * é€»è¾‘å‚æ•°
 * - [bs=]       æ‰¹å¤„ç†èŠ‚ç‚¹æ•°å»ºè®®10ä¸ªå·¦å³ï¼Œå¦‚æœç»å¸¸è¯»ä¸åˆ°èŠ‚ç‚¹å»ºè®®å‡å°æ‰¹å¤„ç†ä¸ªæ•°ï¼›
 * 
 * ç¼“å­˜å‚æ•°
 * - [h=]        èŠ‚ç‚¹ç¼“å­˜æœ‰æ•ˆæœŸï¼Œå•ä½å°æ—¶ï¼Œæ—¶é—´å‚æ•°åªèƒ½äºŒé€‰ä¸€ï¼ŒLoonç”¨æˆ·ä¸éœ€å¡«å†™è¦æ­¤å‚æ•°ï¼Œè¯·è¿›å…¥Sub-Storeæ’ä»¶çš„é…ç½®ç•Œé¢è‡ªå®šä¹‰ç¼“å­˜æœ‰æ•ˆæœŸï¼›
 * - [min=]      èŠ‚ç‚¹ç¼“å­˜æœ‰æ•ˆæœŸï¼Œå•ä½åˆ†é’Ÿï¼Œæ—¶é—´å‚æ•°åªèƒ½äºŒé€‰ä¸€ï¼ŒLoonç”¨æˆ·ä¸éœ€å¡«å†™è¦æ­¤å‚æ•°ï¼Œè¯·è¿›å…¥Sub-Storeæ’ä»¶çš„é…ç½®ç•Œé¢è‡ªå®šä¹‰ç¼“å­˜æœ‰æ•ˆæœŸï¼›
 * 
 * è¶…æ—¶å‚æ•°
 * - [timeout=]  å½“æ— ä»»ä½•èŠ‚ç‚¹ç¼“å­˜æ—¶æµ‹è¯•èŠ‚ç‚¹HTTPå»¶æ—¶å…è®¸çš„æœ€å¤§è¶…æ—¶å‚æ•°ï¼Œè¶…å‡ºå…è®¸èŒƒå›´åˆ™åˆ¤å®šä¸ºæ— æ•ˆèŠ‚ç‚¹ï¼Œé»˜è®¤2000msï¼›
 * - [cd=]       å½“æœ‰ç¼“å­˜æ—¶ï¼Œä¼šå…ˆè¯»å–ç¼“å­˜ï¼Œç›´æ¥è¾“å‡ºç»“æœï¼›é»˜è®¤ [cd=]çš„å€¼ç­‰äº0ï¼Œå¾®ç›´æ¥è¯»å–ç¼“å­˜ï¼› 
 * å½“è®¾ä¸ºæ›´é«˜çš„å€¼: æ¯”å¦‚'460'åˆ™æ¯æ¬¡è¯»ç¼“å­˜éƒ½ä¼šå†æ¬¡å¤„ç†ä¹‹å‰åˆ¤å®šä¸ºè¶…æ—¶çš„èŠ‚ç‚¹,è¶…æ—¶ä¸º460ms
 *
 * å…¶ä»–å‚æ•°
 * - [debug]     è°ƒè¯•æ—¥å¿—ï¼Œæ™®é€šç”¨æˆ·ä¸å»ºè®®ä½¿ç”¨ã€‚
 * - å¼‚å¸¸ï¼šå¦‚é‡é—®é¢˜ï¼ŒLoonå¯ä»¥è¿›å…¥[é…ç½®]â†’[æŒä¹…åŒ–ç¼“å­˜]â†’[åˆ é™¤æŒ‡å®šæ•°æ®]â†’è¾“å…¥Key [sub-store-cached-script-resource]å¹¶åˆ é™¤ç¼“å­˜ã€‚ç´¯è®¡è¾“å‡ºèŠ‚ç‚¹ä¸º0ä¸ª3æ¬¡ä»¥ä¸Šå°†æ¸…ç†æ‰€æœ‰ç¼“å­˜
 * - Surgeéœ€è¦è¿›å…¥[è„šæœ¬ç¼–è¾‘å™¨]â†’å·¦ä¸‹è§’[è®¾ç½®]â†’[$persistentStore]  [sub-store-cached-script-resource]åˆ é™¤ç¼“å­˜æ•°æ®ã€‚
 */

const SUB_STORE_SCHEMA = {
  title: "DENAME",
  description: "æ ¹æ®æ¥å£è¿”å›çš„çœŸå®ç»“æœï¼Œé‡æ–°å¯¹èŠ‚ç‚¹å‘½å/å»é‡ã€‚ å¦‚ï¼šå…¥å£/è½åœ°è¯¦ç»†åœ°åŒºä¿¡æ¯",
  scope: ["Surge", "Loon"],
  author: "@Key @å¥¶èŒ¶å§ @å°ä¸€ @å¯è‰ @ColinYYCC",
  updateTime: "2026-01-22 01:05:00",
  version: "1.2.3",
  params: {
    flag: {
      datatype: "boolean",
      description: "å¢åŠ è½åœ°å›½å®¶æˆ–åœ°åŒºçš„æ——å¸œæ ‡è¯†ï¼Œé»˜è®¤æ— æ­¤å‚æ•°",
      defaultValue: false,
    },
    inflag: {
      datatype: "boolean",
      description: "å¢åŠ å…¥å£å›½å®¶æˆ–åœ°åŒºçš„æ——å¸œæ ‡è¯†ï¼Œé»˜è®¤æ— æ­¤å‚æ•°",
      defaultValue: false,
    },
    xy: {
      datatype: "boolean",
      description: "å…³é—­è½åœ°æŸ¥è¯¢ï¼Œä»…æŸ¥è¯¢å…¥å£ï¼›å¼€å¯ yisp || yw || flag å‚æ•°å xy å‚æ•°æ— æ•ˆ",
      defaultValue: false,
    },
    iisp: {
      datatype: "boolean",
      description: "å¢åŠ å…¥å£è¿è¥å•†æˆ–è€…ç›´è¿æ ‡è¯†",
      defaultValue: false,
    },
    city: {
      datatype: "boolean",
      description: "å¢åŠ å…¥å£åŸå¸‚æ–‡å­—æ ‡è¯†",
      defaultValue: false,
    },
    yuan: {
      datatype: "boolean",
      description: "ä¸ºå¢ƒå¤–å…¥å£æ·»åŠ çœŸå®çš„å…¥å£å±åœ°æ ‡è¯†",
      defaultValue: false,
    },
    sheng: {
      datatype: "boolean",
      description: "å¢åŠ å…¥å£çœä»½æ–‡å­—æ ‡è¯†",
      defaultValue: false,
    },
    offtz: {
      datatype: "boolean",
      description: "å…³é—­è„šæœ¬é€šçŸ¥",
      defaultValue: false,
    },
    game: {
      datatype: "boolean",
      description: "å¢åŠ æ¸¸æˆèŠ‚ç‚¹æ ‡è¯†",
      defaultValue: false,
    },
    yisp: {
      datatype: "boolean",
      description: "æ˜¾ç¤ºè½åœ°è¯¦ç»†è¿è¥å•†åç§°",
      defaultValue: false,
    },
    yw: {
      datatype: "boolean",
      description: "è½åœ°å½’å±åœ°ä½¿ç”¨è‹±æ–‡ç¼©å†™æ ‡è¯†",
      defaultValue: false,
    },
    bl: {
      datatype: "boolean",
      description: "ä¿ç•™å€ç‡æ ‡è¯†",
      defaultValue: false,
    },
    snone: {
      datatype: "boolean",
      description: "æ¸…ç†æŸåœ°åŒºå†…åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„åºå·",
      defaultValue: false,
    },
    dnsjx: {
      datatype: "boolean",
      description: "å°†èŠ‚ç‚¹åŸŸåè§£æä¸ºIP",
      defaultValue: false,
    },
    fgf: {
      datatype: "string",
      description: "è®¾ç½®å…¥å£å’Œè½åœ°ä¹‹é—´çš„åˆ†éš”ç¬¦ï¼Œé»˜è®¤ä¸ºç©ºæ ¼",
      defaultValue: " ",
    },
    sn: {
      datatype: "string",
      description: "è®¾ç½®å›½å®¶ä¸åºå·ä¹‹é—´çš„åˆ†éš”ç¬¦ï¼Œé»˜è®¤ä¸ºç©ºæ ¼",
      defaultValue: " ",
    },
    name: {
      datatype: "string",
      description: "ä¸ºèŠ‚ç‚¹æ·»åŠ æœºåœºåç§°å‰ç¼€",
      defaultValue: "",
    },
    h: {
      datatype: "string",
      description: "èŠ‚ç‚¹ç¼“å­˜æœ‰æ•ˆæœŸï¼Œå•ä½å°æ—¶",
      defaultValue: "",
    },
    min: {
      datatype: "string",
      description: "èŠ‚ç‚¹ç¼“å­˜æœ‰æ•ˆæœŸï¼Œå•ä½åˆ†é’Ÿ",
      defaultValue: "",
    },
    timeout: {
      datatype: "number",
      description: "èŠ‚ç‚¹HTTPå»¶æ—¶å…è®¸çš„æœ€å¤§è¶…æ—¶å‚æ•°ï¼Œé»˜è®¤2000ms",
      defaultValue: 2000,
    },
    cd: {
      datatype: "number",
      description: "å½“æœ‰ç¼“å­˜æ—¶ï¼Œå†æ¬¡å¤„ç†ä¹‹å‰åˆ¤å®šä¸ºè¶…æ—¶çš„èŠ‚ç‚¹",
      defaultValue: 0,
    },
    bs: {
      datatype: "number",
      description: "æ‰¹å¤„ç†èŠ‚ç‚¹æ•°ï¼Œå»ºè®®10ä¸ªå·¦å³",
      defaultValue: 9,
    },
    debug: {
      datatype: "boolean",
      description: "è°ƒè¯•æ—¥å¿—ï¼Œæ™®é€šç”¨æˆ·ä¸å»ºè®®ä½¿ç”¨",
      defaultValue: false,
    },
  },
};

// ç¯å¢ƒå˜é‡å°†åœ¨operatorå‡½æ•°ä¸­è·å–

// å¸¸é‡å®šä¹‰
const CONSTANTS = {
  EXPIRATION_KEY: "#sub-store-csr-expiration-time",
  DEFAULT_CACHE_TIME: 1728e5, // 48å°æ—¶
  MAX_RETRY: 2,
  RANDOM_DELAY_MIN: 50,
  RANDOM_DELAY_MAX: 500,
  keyp: "3.s",
  keypr: "peed"
};

// APIç¼“å­˜è®¡æ•°
let apiRead = 0;
let apiWrite = 0;
let apiCount = 0;

// æ—¥å¿—è®°å½•å‡½æ•°
function log(logType, message) {
  console.log(`[DENAME] [${logType}] ${message}`);
}

// ç”Ÿæˆéšæœºå»¶è¿Ÿæ—¶é—´
function getRandomDelay() {
  return Math.floor(Math.random() * (CONSTANTS.RANDOM_DELAY_MAX - CONSTANTS.RANDOM_DELAY_MIN + 1) + CONSTANTS.RANDOM_DELAY_MIN);
}

// ç¡çœ å‡½æ•°
async function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// è·å–å›½æ——emoji
function getFlag(countryCode) {
  const flagMap = {
    CN: "ğŸ‡¨ğŸ‡³",
    US: "ğŸ‡ºğŸ‡¸",
    JP: "ğŸ‡¯ğŸ‡µ",
    KR: "ğŸ‡°ğŸ‡·",
    SG: "ğŸ‡¸ğŸ‡¬",
    GB: "ğŸ‡¬ğŸ‡§",
    DE: "ğŸ‡©ğŸ‡ª",
    FR: "ğŸ‡«ğŸ‡·",
    AU: "ğŸ‡¦ğŸ‡º",
    CA: "ğŸ‡¨ğŸ‡¦",
    IN: "ğŸ‡®ğŸ‡³",
    RU: "ğŸ‡·ğŸ‡º",
    BR: "ğŸ‡§ğŸ‡·",
    ID: "ğŸ‡®ğŸ‡©",
    TH: "ğŸ‡¹ğŸ‡­",
    MY: "ğŸ‡²ğŸ‡¾",
    VN: "ğŸ‡»ğŸ‡³",
    HK: "ğŸ‡­ğŸ‡°",
    TW: "ğŸ‡¹ğŸ‡¼"
  };
  return flagMap[countryCode] || "";
}

// æ ¼å¼åŒ–æ—¶é—´
function formatTime(ms) {
  if (ms < 1000) {
    return `${ms}ms`;
  } else if (ms < 60 * 1000) {
    return `${Math.round(ms / 1000)}ç§’`;
  } else if (ms < 60 * 60 * 1000) {
    const minutes = Math.floor(ms / (60 * 1000));
    const seconds = Math.round((ms % (60 * 1000)) / 1000);
    return `${minutes}åˆ†${seconds}ç§’`;
  } else {
    const hours = Math.floor(ms / (60 * 60 * 1000));
    const minutes = Math.floor((ms % (60 * 60 * 1000)) / (60 * 1000));
    return `${hours}å°æ—¶${minutes}åˆ†`;
  }
}

// ç”Ÿæˆç¼“å­˜é”®
function getCacheKey(prefix, value) {
  return `${prefix}-${MD5(value)}`;
}

// å¸¦ç¼“å­˜çš„APIè¯·æ±‚
async function fetchApiWithCache(cacheKey, url, options = {}, cacheMap) {
  // æ£€æŸ¥ç¼“å­˜
  if (cacheMap.has(cacheKey)) {
    apiRead++;
    return cacheMap.get(cacheKey);
  }

  try {
    // å‘é€è¯·æ±‚
    const response = await $.http.get(url, options);
    let result = response.body;
    
    // è§£æJSON
    if (typeof result === "string") {
      result = JSON.parse(result);
    }
    
    // ç¼“å­˜ç»“æœ
    cacheMap.set(cacheKey, result);
    apiWrite++;
    
    return result;
  } catch (error) {
    apiCount++;
    console.log(`[DENAME] [ERROR] APIè¯·æ±‚å¤±è´¥: ${url}, é”™è¯¯: ${error.message}`);
    throw error;
  }
}

// è·å–èŠ‚ç‚¹ID
function getNodeId(node) {
  return MD5(`${node.server}-${node.port}`);
}

// è·å–è½åœ°IPä¿¡æ¯
async function getOutboundIP(node, target, oaMap) {
  const cacheKey = getNodeId(node);
  const url = `http://ip-api.com/json?lang=zh-CN&fields=status,message,country,countryCode,city,query,isp`;
  const proxyConfig = typeof ProxyUtils !== 'undefined' ? ProxyUtils.produce([node], target) : node;
  
  return fetchApiWithCache(cacheKey, url, {
    node: proxyConfig,
    "policy-descriptor": proxyConfig
  }, oaMap);
}

// åŸŸåè§£æ
async function resolveDomain(domain, alMap) {
  // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯IPåœ°å€
  const isIP = /^(\d{1,3}\.){3}\d{1,3}$|^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/.test(domain);
  if (isIP) {
    return domain;
  }

  const cacheKey = getCacheKey("al", domain);
  const aliyunDNS = Math.random() < 0.5 ? '223.5.5.5' : '223.6.6.6';
  const url = `https://${aliyunDNS}/resolve?name=${domain}&type=A&short=1`;
  
  try {
    const result = await fetchApiWithCache(cacheKey, url, {}, alMap);
    return result.length > 0 ? result[0] : "keyn";
  } catch (error) {
    return "keyn";
  }
}

// è·å–è¯¦ç»†IPä¿¡æ¯
async function getIPDetails(ip, config, spMap) {
  const cacheKey = getCacheKey("sc", ip);
  const url = `https://api-v${config.keyp}${config.keypr}.cn/ip?ip=${ip}`;
  
  const result = await fetchApiWithCache(cacheKey, url, {}, spMap);
  if (result.data) {
    const { country, province, city, isp, ip: ipAddr, countryCode } = result.data;
    return {
      country,
      regionName: province,
      city,
      isp,
      ip: ipAddr,
      countryCode
    };
  } else {
    throw new Error(result.message || "è·å–IPä¿¡æ¯å¤±è´¥");
  }
}

// è·å–å…¥å£IPä¿¡æ¯
async function getInboundIP(server, iaMap) {
  const cacheKey = getCacheKey("in", server);
  const url = `http://ip-api.com/json/${server}?lang=zh-CN&fields=status,message,country,city,query,regionName,countryCode`;
  
  return fetchApiWithCache(cacheKey, url, {}, iaMap);
}

// ç§»é™¤é‡å¤èŠ‚ç‚¹
function removeDuplicateNodes(nodes) {
  const uniqueKeys = new Set();
  const result = [];
  
  for (const node of nodes) {
    if (node.qc && !uniqueKeys.has(node.qc)) {
      uniqueKeys.add(node.qc);
      result.push(node);
    }
  }
  
  return result;
}

// ç§»é™¤QCå­—æ®µ
function removeQCField(nodes) {
  const uniqueKeys = new Set();
  const result = [];
  
  for (const node of nodes) {
    if (!uniqueKeys.has(node.qc)) {
      uniqueKeys.add(node.qc);
      const { qc, ...rest } = node;
      result.push(rest);
    }
  }
  
  return result;
}

// ä¸ºèŠ‚ç‚¹æ·»åŠ åºå·
function addNodeNumbers(nodes, config) {
  const groupedNodes = nodes.reduce((acc, node) => {
    const existing = acc.find(item => item.name === node.name);
    if (existing) {
      existing.count++;
      existing.items.push({
        ...node,
        name: `${node.name}${config.sn}${existing.count.toString().padStart(2, "0")}`
      });
    } else {
      acc.push({
        name: node.name,
        count: 1,
        items: [{
          ...node,
          name: `${node.name}${config.sn}01`
        }]
      });
    }
    return acc;
  }, []);
  
  const result = groupedNodes.flatMap(item => item.items);
  nodes.splice(0, nodes.length, ...result);
  return nodes;
}

// æ¸…ç†å•ä¸ªèŠ‚ç‚¹çš„åºå·
function cleanupSingleNodeNumbers(nodes) {
  const groupedNodes = nodes.reduce((acc, node) => {
    const baseName = node.name.replace(/[^A-Za-z0-9\u00C0-\u017F\u4E00-\u9FFF]+\d+$/, "");
    if (!acc[baseName]) {
      acc[baseName] = [];
    }
    acc[baseName].push(node);
    return acc;
  }, {});
  
  for (const key in groupedNodes) {
    if (groupedNodes[key].length === 1 && groupedNodes[key][0].name.endsWith("01")) {
      groupedNodes[key][0].name = groupedNodes[key][0].name.replace(/[^.]01/, "");
    }
  }
  
  return Object.values(groupedNodes).flat();
}

async function processNode(node, config, features, cacheMaps, target) {
  try {
    let { server } = node;
    let landingInfo = "", inQcip = "",å€ç‡Info = "", flag = "", gameFlag = "", isp = "", ispFlag = "", province = "", city = "", directFlag = "", landingIsp = "";
    let isCN = false, isV4 = false, isV6 = false, isNoAli = false;
    
    // åŸŸåè§£æ
    if (features.dns && !features.xy) {
      server = await resolveDomain(server, cacheMaps.al);
    }
    
    node.server = server;
    let resolvedServer = server;
    
    // æ£€æŸ¥è§£æç»“æœ
    if (resolvedServer === "keyn") {
      isNoAli = true;
      resolvedServer = server;
    } else {
      node.keyrk = resolvedServer;
      if (/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(resolvedServer)) {
        isV4 = true;
      } else if (/^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/.test(resolvedServer)) {
        isV6 = true;
      }
    }
    
    let isDirect = true, landingCountryCode = "", landingQuery = "";
    
    // è·å–è½åœ°IPä¿¡æ¯
    if (!features.xy || features.yisp || features.yw || features.flag) {
      try {
        const outboundIP = await getOutboundIP(node, target, cacheMaps.oa);
        const { country: outCountry, countryCode: outCode, city: outCity, query: outQuery, isp: outIsp } = outboundIP;
        
        if (features.yisp) {
          landingIsp = config.fgfs + outIsp;
        }
        
        if (config.debug) {
          console.log(`[DENAME] [DEBUG] è½åœ°ä¿¡æ¯: ${JSON.stringify(outboundIP)}`);
        }
        
        landingCountryCode = outCode;
        landingQuery = outQuery;
        landingInfo = (outCountry === "ä¸­å›½") ? outCity : (features.yw ? outCode : outCountry);
        isDirect = outQuery !== resolvedServer;
      } catch (error) {
        console.log(`[DENAME] [DEBUG] è·å–è½åœ°IPä¿¡æ¯å¤±è´¥: ${error.message}`);
      }
    }
    
    // è·å–å…¥å£IPä¿¡æ¯
    if (isDirect || features.xy) {
      if (!isNoAli || isV4) {
        try {
          const ipDetails = await getIPDetails(resolvedServer, config, cacheMaps.sp);
          const { country: inCountry, regionName: inProvince, city: inCity, isp: inIsp, countryCode: inCode } = ipDetails;
          
          if (features.inflag) {
            flag = getFlag(inCode);
          }
          
          if (config.debug) {
            console.log(`[DENAME] [DEBUG] å›½å†…å…¥å£ä¿¡æ¯: ${JSON.stringify(ipDetails)}`);
          }
          
          isCN = inCountry === "ä¸­å›½";
          inQcip = resolvedServer;
          
          const ispMap = {ç”µä¿¡: "ğŸ…³", è”é€š: "ğŸ…»", ç§»åŠ¨: "ğŸ†ˆ", å¹¿ç”µ: "ğŸ…¶"};
          isp = inIsp;
          ispFlag = ispMap[inIsp] || "ğŸ…²";
          
          province = inProvince;
          city = inCity;
        } catch (error) {
          console.log(`[DENAME] [DEBUG] è·å–å…¥å£IPä¿¡æ¯å¤±è´¥: ${error.message}`);
        }
      }
    }
    
    // å¤„ç†æ¸¸æˆèŠ‚ç‚¹æ ‡è¯†
    if (features.game && isCN) {
      gameFlag = "ğŸ®";
    }
    
    // å¤„ç†ç›´è¿æ ‡è¯†
    if (isDirect) {
      directFlag = "ğŸ†‰";
    }
    
    // æ„å»ºèŠ‚ç‚¹åç§°
    let nodeName = "";
    
    if (isCN || features.yuan) {
      nodeName += `${features.inflag ? flag : ""}${features.iisp ? ispFlag : ""}${features.sheng ? province : ""}${features.city ? city : ""}${features.yisp ? landingIsp : ""}${features.fgf ? config.fgf : ""}`;
    } else {
      nodeName += `${features.inflag ? flag : ""}[å¢ƒå¤–]${features.fgf ? config.fgf : ""}`;
    }
    
    nodeName += `${features.flag ? getFlag(landingCountryCode) : ""}${landingInfo}${features.bl ? å€ç‡Info : ""}${gameFlag}`;
    
    // æ·»åŠ æœºåœºåç§°å‰ç¼€
    if (config.firstN) {
      nodeName = `${config.firstN}${nodeName}`;
    }
    
    // æ›´æ–°èŠ‚ç‚¹åç§°
    node.name = nodeName;
    
    return node;
  } catch (error) {
    console.log(`[DENAME] [ERROR] å¤„ç†èŠ‚ç‚¹å¤±è´¥: ${node.server}, é”™è¯¯: ${error.message}`);
    return node; // è¿”å›åŸå§‹èŠ‚ç‚¹ï¼Œé¿å…æ•´ä¸ªæ‰¹å¤„ç†å¤±è´¥
  }
}

/**
 * å¤„ç†èŠ‚ç‚¹åˆ—è¡¨
 * @param {Array<Object>} nodes - èŠ‚ç‚¹åˆ—è¡¨
 * @param {string} tzname - è®¢é˜…åç§°
 * @param {string} subcoll - è®¢é˜…ç±»å‹
 * @param {number} totalNodes - æ€»èŠ‚ç‚¹æ•°
 * @param {number} batchSize - æ‰¹å¤„ç†å¤§å°
 * @param {boolean} useCache - æ˜¯å¦ä½¿ç”¨ç¼“å­˜
 * @param {Object} config - é…ç½®å‚æ•°
 * @param {Object} features - åŠŸèƒ½å¼€å…³
 * @param {Object} cacheMaps - ç¼“å­˜æ˜ å°„
 * @param {string} target - ç›®æ ‡å¹³å°
 * @returns {Promise<Array<Object>>} å¤„ç†åçš„èŠ‚ç‚¹åˆ—è¡¨
 */
async function processNodes(nodes, tzname, subcoll, totalNodes, batchSize, useCache, config, features, cacheMaps, target) {
  const processedNodes = [];
  const landingIps = [];
  
  // æ—¥å¿—è®°å½•å‡½æ•°
  const log = (logType, message) => {
    if (config.debug) {
      console.log(`[DENAME] [${logType}] ${message}`);
    }
  };
  
  // ç”Ÿæˆéšæœºå»¶è¿Ÿæ—¶é—´
  const getRandomDelay = () => {
    return Math.floor(Math.random() * (config.RANDOM_DELAY_MAX - config.RANDOM_DELAY_MIN + 1) + config.RANDOM_DELAY_MIN);
  };
  
  // ç¡çœ å‡½æ•°
  const sleep = (ms) => {
    return new Promise(resolve => setTimeout(resolve, ms));
  };
  
  for (let i = 0; i < nodes.length; i += batchSize) {
    const batch = nodes.slice(i, i + batchSize);
    
    const batchResults = await Promise.all(
      batch.map(async (node) => {
        try {
          const processedNode = await processNode(node, config, features, cacheMaps, target);
          // æ·»åŠ qcå±æ€§ä»¥ä¾¿å»é‡
          if (!processedNode.qc) {
            processedNode.qc = `${processedNode.server}-${processedNode.port}`;
          }
          if (processedNode.qc) {
            landingIps.push(processedNode.qc.charAt(processedNode.qc.length - 1));
          }
          return processedNode;
        } catch (error) {
          log("ERROR", `å¤„ç†èŠ‚ç‚¹å¤±è´¥: ${node.server}, é”™è¯¯: ${error.message}`);
          return null;
        }
      })
    );
    
    const validNodes = batchResults.filter(node => node !== null);
    processedNodes.push(...validNodes);
    
    // éšæœºå»¶è¿Ÿï¼Œé¿å…APIè¯·æ±‚è¿‡å¿«
    await sleep(getRandomDelay());
  }
  
  return {
    processedNodes,
    landingIps
  };
}

/**
 * ä¸»å‡½æ•°
 * @param {Array<Object>} nodes - èŠ‚ç‚¹åˆ—è¡¨
 * @param {string} targetPlatform - ç›®æ ‡å¹³å°
 * @param {Object} env - ç¯å¢ƒå˜é‡
 * @returns {Array<Object>} å¤„ç†åçš„èŠ‚ç‚¹åˆ—è¡¨
 */
async function operator(nodes = [], targetPlatform, env) {
  // è·å–å…¨å±€å˜é‡
  const $ = typeof $substore !== 'undefined' ? $substore : {
    http: { get: async () => ({ body: '{}' }) },
    write: () => {},
    read: () => null,
    notify: () => {}
  };
  
  // ç¯å¢ƒå˜é‡
  const isLoon = env ? env.isLoon : false;
  const isSurge = env ? env.isSurge : false;
  const target = isLoon ? "Loon" : isSurge ? "Surge" : undefined;
  
  // è·å–å‚æ•°
  const scriptArgs = typeof $arguments !== 'undefined' ? $arguments : {};
  const args = scriptArgs;
  
  // é…ç½®å‚æ•°
  const config = {
    debug: args.debug || false,
    fgf: args.fgf ? decodeURI(args.fgf) : " ",
    fgfs: args.fgf ? decodeURI(args.fgf) : " ",
    h: args.h ? decodeURI(args.h) : "",
    min: args.min ? decodeURI(args.min) : "",
    firstN: args.name ? decodeURI(args.name) : "",
    sn: args.sn ? decodeURI(args.sn) : " ",
    cd: args.cd || 0,
    timeout: args.timeout || 2000,
    bs: args.bs || 9,
    keyp: CONSTANTS.keyp,
    keypr: CONSTANTS.keypr,
    EXPIRATION_KEY: CONSTANTS.EXPIRATION_KEY,
    DEFAULT_CACHE_TIME: CONSTANTS.DEFAULT_CACHE_TIME,
    MAX_RETRY: CONSTANTS.MAX_RETRY,
    MAX_TIMEOUT: 460,
    RANDOM_DELAY_MIN: CONSTANTS.RANDOM_DELAY_MIN,
    RANDOM_DELAY_MAX: CONSTANTS.RANDOM_DELAY_MAX
  };
  
  // åŠŸèƒ½å¼€å…³
  const features = {
    yw: args.yw,
    bl: args.bl,
    iisp: args.iisp,
    xy: args.xy,
    yisp: args.yisp,
    yuan: args.yuan,
    city: args.city,
    flag: args.flag,
    inflag: args.inflag,
    game: args.game,
    sheng: args.sheng,
    offtz: args.offtz,
    numone: args.snone,
    dns: args.dnsjx
  };
  
  // åˆå§‹åŒ–ç¼“å­˜
  let useCache = true;
  let cacheTime = config.DEFAULT_CACHE_TIME;
  let TIMEDKEY = cacheTime;
  let cacheExpireTime = "";
  
  // APIç¼“å­˜æ˜ å°„
  const spMap = new Map();
  const alMap = new Map();
  const iaMap = new Map();
  const oaMap = new Map();
  
  // æ£€æŸ¥æ˜¯å¦éœ€è¦è‡ªå®šä¹‰ç¼“å­˜æ—¶é—´
  const useCustomCacheTime = config.h !== "" || config.min !== "";
  if (useCustomCacheTime) {
    cacheTime = config.h ? parseInt(config.h, 10) * 36e5 : parseInt(config.min, 10) * 6e4;
    TIMEDKEY = cacheTime;
    
    // å†™å…¥ç¼“å­˜æ—¶é—´
    $.write(JSON.stringify(cacheTime), config.EXPIRATION_KEY);
  } else {
    // è¯»å–ç¼“å­˜æ—¶é—´
    const cacheTimeStr = $.read(config.EXPIRATION_KEY);
    if (cacheTimeStr) {
      TIMEDKEY = parseInt(cacheTimeStr, 10);
    }
  }
  
  const startTime = new Date();
  const currentTime = startTime.getTime();
  
  // è¯»å–ç¼“å­˜
  const cacheMap = {
    sp: spMap,
    al: alMap,
    ia: iaMap,
    oa: oaMap
  };
  
  let subcoll = args.name ? decodeURI(args.name) : "", tzname = "";
  
  // å¤„ç†è®¢é˜…ä¿¡æ¯
  if (env && env.subInfo && env.subInfo.title) {
    tzname = env.subInfo.title;
  }
  
  // æ£€æŸ¥ç¼“å­˜è¿‡æœŸæ—¶é—´
  const cacheExpirationTime = $.read(config.EXPIRATION_KEY);
  if (cacheExpirationTime) {
    const expireTime = parseInt(cacheExpirationTime, 10);
    const remainingTime = expireTime - currentTime;
    if (remainingTime > 0) {
      cacheExpireTime = formatTime(remainingTime);
    }
  }
  
  // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡æ–°ç”Ÿæˆç¼“å­˜
  if (useCustomCacheTime) {
    cacheExpireTime = formatTime(cacheTime);
  } else if (target === "Loon") {
    const loonCacheMap = {
      "1åˆ†é’Ÿ": 6e4, "5åˆ†é’Ÿ": 3e5, "10åˆ†é’Ÿ": 6e5, "30åˆ†é’Ÿ": 18e5,
      "1å°æ—¶": 36e5, "2å°æ—¶": 72e5, "3å°æ—¶": 108e5, "6å°æ—¶": 216e5,
      "12å°æ—¶": 432e5, "24å°æ—¶": 864e5, "48å°æ—¶": 1728e5, "72å°æ—¶": 2592e5,
      "å‚æ•°ä¼ å…¥": "innums"
    };
    
    const loonCacheSetting = $.read("#èŠ‚ç‚¹ç¼“å­˜æœ‰æ•ˆæœŸ");
    let loonCacheTime = loonCacheMap[loonCacheSetting] || 1728e5;
    
    if (loonCacheTime === "innums") {
      loonCacheTime = cacheTime;
    }
    
    cacheExpireTime = formatTime(parseInt(cacheExpirationTime, 10) - currentTime + parseInt(loonCacheTime, 10));
  } else if (target === "Surge" && useCustomCacheTime) {
    cacheExpireTime = formatTime(parseInt(cacheExpirationTime, 10) - currentTime + parseInt(cacheTime, 10));
  } else {
    cacheExpireTime = formatTime(parseInt(cacheExpirationTime, 10) - currentTime + parseInt(TIMEDKEY, 10));
  }
  
  // å‘é€å¼€å§‹å¤„ç†é€šçŸ¥
  if (!useCache && !features.offtz) {
    $.notify(subcoll + tzname, `å¼€å§‹å¤„ç†èŠ‚ç‚¹: ${nodes.length} ä¸ª æ‰¹å¤„ç†æ•°é‡: ${config.bs} ä¸ª`, "è¯·ç­‰å¾…å¤„ç†å®Œæ¯•åå†æ¬¡ç‚¹å‡»é¢„è§ˆ");
  }
  
  // å¤„ç†èŠ‚ç‚¹
  let retryCount = 0;
  let breakFlag = false;
  let processedNodes = [];
  let landingIps = [];
  
  // ç¼“å­˜æ˜ å°„
  const cacheMaps = {
    sp: spMap,
    al: alMap,
    ia: iaMap,
    oa: oaMap
  };
  
  do {
    try {
      const result = await processNodes(nodes, tzname, subcoll, nodes.length, config.bs, useCache, config, features, cacheMaps, target);
      processedNodes = result.processedNodes;
      landingIps = result.landingIps;
      break;
    } catch (error) {
      console.log(`[DENAME] [ERROR] å¤„ç†èŠ‚ç‚¹å¤±è´¥: ${error.message}`);
      if (apiCount >= 1) {
        retryCount++;
        breakFlag = true;
      }
    }
  } while (retryCount < 2);
  
  // å»é‡å¤„ç†
  if (!features.xy) {
    processedNodes = removeDuplicateNodes(processedNodes);
  }
  
  const finalNodeCount = processedNodes.length;
  
  // æ£€æŸ¥Surgeå¹³å°è½åœ°IPæ˜¯å¦ç›¸åŒ
  if (finalNodeCount > 3 && isSurge) {
    const allSame = landingIps.every((value, index, arr) => value === arr[0]);
    if (allSame) {
      if (config.debug) {
        console.log(`[DENAME] [DEBUG] æœªä½¿ç”¨å¸¦æŒ‡å®šèŠ‚ç‚¹åŠŸèƒ½çš„ SubStore, æˆ–æ‰€æœ‰èŠ‚ç‚¹è½åœ°IPç›¸åŒ`);
      }
      $.notify('DENAMEï¼šç‚¹å‡»ä»¥å®‰è£…å¯¹åº”ç‰ˆæœ¬', 'æœªä½¿ç”¨å¸¦æŒ‡å®šèŠ‚ç‚¹åŠŸèƒ½çš„ SubStoreï¼Œæˆ–æ‰€æœ‰èŠ‚ç‚¹è½åœ°IPç›¸åŒ', '', {
        url: "https://raw.githubusercontent.com/sub-store-org/Sub-Store/master/config/Surge-ability.sgmodule"
      });
    }
  }
  
  // é‡è¯•é€»è¾‘
  if (apiCount >= 1) {
    retryCount++;
    config.timeout = config.DEFAULT_CACHE_TIME;
    useCache = false;
    
    // æ¸…ç©ºç¼“å­˜æ˜ å°„
    spMap.clear();
    alMap.clear();
    iaMap.clear();
    oaMap.clear();
    
    if (config.debug) {
      console.log(`[DENAME] [DEBUG] é‡è¯•ä¸­...`);
    }
  } else {
    retryCount = 2;
  }
  
  // ç§»é™¤QCå­—æ®µ
  if (!features.xy) {
    processedNodes = removeQCField(processedNodes);
  }
  
  // ä¸ºèŠ‚ç‚¹æ·»åŠ åºå·
  processedNodes = addNodeNumbers(processedNodes, config);
  
  // æ¸…ç†å•ä¸ªèŠ‚ç‚¹çš„åºå·
  if (features.numone) {
    processedNodes = cleanupSingleNodeNumbers(processedNodes);
  }
  
  const endTime = new Date();
  const totalTime = endTime.getTime() - startTime.getTime();
  
  // è¾“å‡ºå¤„ç†ç»“æœ
  if (features.dns) {
    if (config.debug) {
      console.log(`[DENAME] [DEBUG] dnsè§£æåå…±: ${finalNodeCount} ä¸ª`);
    }
  }
  
  if (apiRead > 0) {
    if (config.debug) {
      console.log(`[DENAME] [DEBUG] è¯»å–apiç¼“å­˜: ${apiRead} ä¸ª`);
    }
  }
  
  if (apiWrite > 0) {
    if (config.debug) {
      console.log(`[DENAME] [DEBUG] å†™å…¥apiç¼“å­˜: ${apiWrite} ä¸ª`);
    }
  }
  
  if (config.debug) {
    console.log(`[DENAME] [DEBUG] å¤„ç†å®Œåå‰©ä½™: ${finalNodeCount} ä¸ª`);
  }
  
  // è¾“å‡ºç¼“å­˜è¿‡æœŸæ—¶é—´
  if (isLoon) {
    const loonCacheSetting = $.read("#èŠ‚ç‚¹ç¼“å­˜æœ‰æ•ˆæœŸ");
    if (config.debug) {
      console.log(`[DENAME] [DEBUG] ç¼“å­˜è¿‡æœŸæ—¶é—´: ${loonCacheSetting}, è¿˜å‰© ${cacheExpireTime.replace(/,|\n/g, "")}`);
    }
  } else {
    if (config.debug) {
      console.log(`[DENAME] [DEBUG] ç¼“å­˜è¿‡æœŸæ—¶é—´: ${formatTime(TIMEDKEY)}, è¿˜å‰© ${cacheExpireTime.replace(/,|\n/g, "")}`);
    }
  }
  
  if (config.debug) {
    console.log(`[DENAME] [DEBUG] æ­¤æ–¹æ³•æ€»ç”¨æ—¶: ${formatTime(totalTime)}\n----For New DENAME----\n\n\n\n\n`);
  }
  
  // å‘é€å®Œæˆé€šçŸ¥
  const readLog = apiRead ? `è¯»å–ç¼“å­˜:${apiRead} ` : "";
  const writeLog = apiWrite ? `å†™å…¥ç¼“å­˜:${apiWrite}, ` : "";
  const resultMsg = (finalNodeCount === nodes.length && finalNodeCount === 0) ? "" : 
                    (finalNodeCount === nodes.length ? "å…¨éƒ¨é€šè¿‡æµ‹è¯•, " : `å»é™¤æ— æ•ˆèŠ‚ç‚¹åæœ‰${finalNodeCount}ä¸ª, `);
  
  if (!features.offtz) {
    $.notify(
      `${subcoll}${tzname} å…±${nodes.length}ä¸ªèŠ‚ç‚¹`,
      "",
      `${writeLog}${readLog}${cacheExpireTime ? `, ${cacheExpireTime}åè¿‡æœŸ ` : ""}${resultMsg}ç”¨æ—¶:${formatTime(totalTime)}`
    );
  }
  
  return processedNodes;
}

// MD5åŠ å¯†å‡½æ•° (ç®€åŒ–ç‰ˆï¼Œä»…ç”¨äºç”Ÿæˆç¼“å­˜é”®)
function MD5(str) {
  const crypto = require('crypto');
  return crypto.createHash('md5').update(str).digest('hex');
}

// å¯¼å‡ºä¸»å‡½æ•°
module.exports = {
  operator: operator
};
